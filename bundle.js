!function(){"use strict";function t(t,e,i){return{x:t,y:e,z:i}}function e(t,e){const i=t.x,s=t.y,n=t.z,o=e.x,r=e.y,a=e.z;return Math.sqrt((i-o)*(i-o)+(s-r)*(s-r)+(n-a)*(n-a))}function i(t){return Math.sqrt(s(t))}function s(t){const e=t.x,i=t.y,s=t.z;return e*e+i*i+s*s}function n(t,e){return t.x+=e.x,t.y+=e.y,t.z+=e.z,t}function o(t,e){return{x:t.x-e.x,y:t.y-e.y,z:t.z-e.z}}function r(t,e){return{x:t.x*e,y:t.y*e,z:t.z*e}}function a(t,e){const i=t.x,s=t.y,n=t.z,o=e.x,r=e.y,a=e.z;return{x:s*a-n*r,y:n*o-i*a,z:i*r-s*o}}function c(t,e){const i=t.x,s=t.y,n=t.z,o=e.x,r=e.y,a=e.z;return t.x=s*a-n*r,t.y=n*o-i*a,t.z=i*r-s*o,t}function h(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[12]=t.x,e[13]=t.y,e[14]=t.z,e}function f(t){return function(t,e){const i=Math.sin(e),s=Math.cos(e),n=t[0],o=t[1],r=t[2],a=t[3],c=t[4],h=t[5],f=t[6],u=t[7];return t[0]=n*s+c*i,t[1]=o*s+h*i,t[2]=r*s+f*i,t[3]=a*s+u*i,t[4]=c*s-n*i,t[5]=h*s-o*i,t[6]=f*s-r*i,t[7]=u*s-a*i,t}(function(t,e){const i=Math.sin(e),s=Math.cos(e),n=t[0],o=t[1],r=t[2],a=t[3],c=t[8],h=t[9],f=t[10],u=t[11];return t[0]=n*s-c*i,t[1]=o*s-h*i,t[2]=r*s-f*i,t[3]=a*s-u*i,t[8]=n*i+c*s,t[9]=o*i+h*s,t[10]=r*i+f*s,t[11]=a*i+u*s,t}(function(t,e){const i=Math.sin(e),s=Math.cos(e),n=t[4],o=t[5],r=t[6],a=t[7],c=t[8],h=t[9],f=t[10],u=t[11];return t[4]=n*s+c*i,t[5]=o*s+h*i,t[6]=r*s+f*i,t[7]=a*s+u*i,t[8]=c*s-n*i,t[9]=h*s-o*i,t[10]=f*s-r*i,t[11]=u*s-a*i,t}([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t.x),t.y),t.z)}function u(t,e){const i=t[0],s=t[1],n=t[2],o=t[3],r=t[4],a=t[5],c=t[6],h=t[7],f=t[8],u=t[9],l=t[10],p=t[11],d=t[12],g=t[13],m=t[14],v=t[15];let b=e[0],y=e[1],w=e[2],P=e[3];return t[0]=b*i+y*r+w*f+P*d,t[1]=b*s+y*a+w*u+P*g,t[2]=b*n+y*c+w*l+P*m,t[3]=b*o+y*h+w*p+P*v,b=e[4],y=e[5],w=e[6],P=e[7],t[4]=b*i+y*r+w*f+P*d,t[5]=b*s+y*a+w*u+P*g,t[6]=b*n+y*c+w*l+P*m,t[7]=b*o+y*h+w*p+P*v,b=e[8],y=e[9],w=e[10],P=e[11],t[8]=b*i+y*r+w*f+P*d,t[9]=b*s+y*a+w*u+P*g,t[10]=b*n+y*c+w*l+P*m,t[11]=b*o+y*h+w*p+P*v,b=e[12],y=e[13],w=e[14],P=e[15],t[12]=b*i+y*r+w*f+P*d,t[13]=b*s+y*a+w*u+P*g,t[14]=b*n+y*c+w*l+P*m,t[15]=b*o+y*h+w*p+P*v,t}class l{constructor(t,e){this.buffer=t,this.offset=e}get x(){return this.buffer[this.offset]}set x(t){this.buffer[this.offset]=t}get y(){return this.buffer[this.offset+1]}set y(t){this.buffer[this.offset+1]=t}get z(){return this.buffer[this.offset+2]}set z(t){this.buffer[this.offset+2]=t}}class p{constructor(t,e,i){this.id=t,this.buffer=e,this.offset=i}get position(){const t=this.offset+p.positionOffset;return new l(this.buffer,t)}set position(t){const e=this.offset+p.positionOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}get estimatedPosition(){const t=this.offset+p.estimatedPositionOffset;return new l(this.buffer,t)}set estimatedPosition(t){const e=this.offset+p.estimatedPositionOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}get deltaPosition(){const t=this.offset+p.deltaPositionOffset;return new l(this.buffer,t)}set deltaPosition(t){const e=this.offset+p.deltaPositionOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}get velocity(){const t=this.offset+p.velocityOffset;return new l(this.buffer,t)}set velocity(t){const e=this.offset+p.velocityOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}get inverseMass(){return this.buffer[this.offset+p.inverseMassOffset]}set inverseMass(t){this.buffer[this.offset+p.inverseMassOffset]=t}}p.positionOffset=0,p.estimatedPositionOffset=3,p.deltaPositionOffset=6,p.velocityOffset=9,p.inverseMassOffset=12,p.components=13;class d{constructor(t){this.buffer=new Float32Array(t*p.components),this.count=0}add(t){const e=this.count,i=this.count*p.components,s=new p(e,this.buffer,i);s.position=t.position,s.estimatedPosition=t.estimatedPosition,s.deltaPosition=t.deltaPosition,s.velocity=t.velocity,s.inverseMass=t.inverseMass,this.count++}get(t){return new p(t,this.buffer,t*p.components)}forEach(t){for(let e=0;e<this.count;e++)t(new p(e,this.buffer,e*p.components))}}const g=new class{constructor(){this.pending=[]}attach(t){this.el=t,setInterval((()=>this.flush()),100)}flush(){this.pending.length&&(this.pending.forEach((t=>{const e=document.createElement("p"),i=t.date.toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"}),s=this.replaceStrongMarkers(t.message);e.innerHTML=`<span class="date">${i}&nbsp&nbsp</span><span class="message">${s}</span>`,this.el.appendChild(e)})),this.el.scrollTop=this.el.scrollHeight,this.pending=[])}replaceStrongMarkers(t){const e="**";let i="";for(;;){const s=t.indexOf(e);if(-1===s)return i+t;const n=t.slice(s+e.length).indexOf(e);if(-1===n)return i+t;i+=t.slice(0,s),i+=`<span class="strong">${t.slice(s+e.length,s+e.length+n)}</span>`,t=t.slice(s+e.length+n+e.length)}}info(t){this.pending.push({date:new Date,message:t})}warn(t){this.pending.push({date:new Date,message:t})}error(t){this.pending.push({date:new Date,message:t})}};function m(t){return"object"==typeof t?JSON.stringify(t):t.toString()}var v,b;!function(t){t.Jacobi="jacobi",t.GaussSeidel="gauss-seidel"}(v||(v={}));class y{constructor(t){this.paused=!0,this._config={},this.config=t}solve(t){if(this.paused)return;const e=this._config.deltaTime/this._config.subSteps,i=1/e,s=r(this._config.gravity,e);for(let a=0;a<this._config.subSteps;a++)t.particles.forEach((t=>{var i,o;t.inverseMass>0&&n(t.velocity,s),t.estimatedPosition=(i=t.position,o=r(t.velocity,e),{x:i.x+o.x,y:i.y+o.y,z:i.z+o.z})})),t.constraints.project(t.particles,e,{method:this.config.method,stretchCompliance:this.config.stretchCompliance,bendCompliance:this.config.bendCompliance,relaxation:this.config.relaxation}),t.particles.forEach((t=>{this._config.method===v.Jacobi&&(n(t.estimatedPosition,t.deltaPosition),t.deltaPosition={x:0,y:0,z:0}),t.velocity=r(o(t.estimatedPosition,t.position),i),t.position=t.estimatedPosition}));t.updatePositionsAndNormals()}set config(t){const e=Object.assign(Object.assign({},y.defaultConfig),t);Object.keys(e).forEach((t=>{const i=this._config[t],s=e[t];s!==i&&g.info(`${t}: **${m(s)}**`)})),this._config=e}get config(){return this._config}}y.defaultConfig={deltaTime:1/60,subSteps:10,gravity:t(0,-9.8,0),stretchCompliance:0,bendCompliance:.3,relaxation:.2,method:v.GaussSeidel},function(t){t[t.Stretch=0]="Stretch",t[t.Bend=1]="Bend"}(b||(b={}));class w{constructor(t,e){this.buffer=t,this.offset=e}project(t,e,s){const a=t.get(this.p1),c=t.get(this.p2),h=a.inverseMass+c.inverseMass;if(0===h)return;const f=(this.type===b.Stretch?s.stretchCompliance:s.bendCompliance)/(e*e),u=o(a.estimatedPosition,c.estimatedPosition);let l=i(u);if(l<1e-6)return;const p=function(t,e){if(!e)throw new Error("divideByScalar: division by 0");return{x:t.x/e,y:t.y/e,z:t.z/e}}(u,l),d=-(l-this.restValue)/(h+f)*s.relaxation,g=r(p,d*a.inverseMass),m=r(p,-d*c.inverseMass);s.method===v.Jacobi?(n(a.deltaPosition,g),n(c.deltaPosition,m)):(n(a.estimatedPosition,g),n(c.estimatedPosition,m))}get p1(){return this.buffer[this.offset+w.p1Offset]}set p1(t){this.buffer[this.offset+w.p1Offset]=t}get p2(){return this.buffer[this.offset+w.p2Offset]}set p2(t){this.buffer[this.offset+w.p2Offset]=t}get restValue(){return this.buffer[this.offset+w.restValueOffset]}set restValue(t){this.buffer[this.offset+w.restValueOffset]=t}get type(){return this.buffer[this.offset+w.typeOffset]}set type(t){this.buffer[this.offset+w.typeOffset]=t}}w.components=4,w.typeOffset=0,w.restValueOffset=1,w.p1Offset=2,w.p2Offset=3;class P{constructor(t){this.buffer=new Float32Array(t*w.components),this.count=0}addStretch(t,i){if(this.count+1>=this.buffer.length/2)throw new Error("max number of constraints reached");const s=this.count*w.components,n=new w(this.buffer,s);n.type=b.Stretch,n.restValue=e(t.position,i.position),n.p1=t.id,n.p2=i.id,this.count++}addBend(t,i){if(this.count+1>=this.buffer.length/2)throw new Error("max number of constraints reached");const s=this.count*w.components,n=new w(this.buffer,s);n.type=b.Bend,n.restValue=e(t.position,i.position),n.p1=t.id,n.p2=i.id,this.count++}project(t,e,i){for(let s=0;s<this.count;s++){const n=s*w.components;new w(this.buffer,n).project(t,e,i)}}}class x{constructor(t,e,i,s){this.device=t,this.geometry=e,this.updated=!1,this._position={x:0,y:0,z:0},this._rotation={x:0,y:0,z:0},i&&(this.position=i),s&&(this.rotation=s),this.renderPipeline=null}set geometry(t){this._geometry=t,this.particles=function(t){const e=new d(t.vertices.count);t.vertices.forEach((t=>{e.add({position:t.position,velocity:{x:0,y:0,z:0},estimatedPosition:{x:0,y:0,z:0},deltaPosition:{x:0,y:0,z:0},inverseMass:0})}));for(let s of t.topology.triangles){const t=e.get(s.a),n=e.get(s.b),r=e.get(s.c),a=1/(.5*i(c(o(n.position,t.position),o(r.position,t.position)))*.01*.27)/3;t.inverseMass+=a,n.inverseMass+=a,r.inverseMass+=a}return e.forEach((t=>{0===t.position.z&&(t.inverseMass=0)})),e}(this._geometry),this.constraints=function(t,e){const i=[];for(let e of t.topology.edges)i.push({type:b.Stretch,p1:e.start,p2:e.end});for(let e of t.topology.edges){if(1==e.triangles.length)continue;if(2!=e.triangles.length)throw new Error(`Non-manifold mesh: ${e.start}-${e.end} shared with ${e.triangles.length} triangles`);const s=t.topology.triangles[e.triangles[0]],n=t.topology.triangles[e.triangles[1]];let o,r;o=s.a!=e.start&&s.a!=e.end?s.a:s.b!=e.start&&s.b!=e.end?s.b:s.c,r=n.a!=e.start&&n.a!=e.end?n.a:n.b!=e.start&&n.b!=e.end?n.b:n.c,i.push({type:b.Bend,p1:o,p2:r})}!function(t){for(let e=t.length-1;e>=1;e--){const i=Math.floor(Math.random()*(e+1)),s=t[i];t[i]=t[e],t[e]=s}}(i);const s=new P(i.length);for(let t of i)t.type===b.Stretch?s.addStretch(e.get(t.p1),e.get(t.p2)):s.addBend(e.get(t.p1),e.get(t.p2));return s}(this._geometry,this.particles),this.maxParticleMass=0,this.particles.forEach((t=>{const e=1/t.inverseMass;e!==1/0&&e>this.maxParticleMass&&(this.maxParticleMass=e)})),g.info(`vertices: **${this._geometry.vertices.count}**`),g.info(`triangles: **${this._geometry.topology.triangles.length}**`),g.info(`edges: **${this._geometry.topology.edges.length}**`),g.info(`constraints: **${this.constraints.count}**`),g.info(`max particle mass: **${this.maxParticleMass}** kg`)}get geometry(){return this._geometry}set position(t){this._position=t,this.updated=!0}get position(){return this._position}set rotation(t){this._rotation=t,this.updated=!0}get rotation(){return this._rotation}set wireframe(t){this._geometry.wireframe=t,this.renderPipeline=null}get wireframe(){return this._geometry.wireframe}updatePositionsAndNormals(){this._geometry.vertices.forEach((t=>{const e=this.particles.get(t.id);t.position=e.position,t.normal={x:0,y:0,z:0}}));for(let t of this._geometry.topology.triangles){const e=this._geometry.vertices.get(t.a),i=this._geometry.vertices.get(t.b),s=this._geometry.vertices.get(t.c),r=a(o(i.position,e.position),o(s.position,e.position));n(e.normal,r),n(i.normal,r),n(s.normal,r)}this._geometry.vertices.forEach((t=>{!function(t){let e=s(t);e>0&&(e=1/Math.sqrt(e)),t.x*=e,t.y*=e,t.z*=e}(t.normal),t.color=t.normal})),this._geometry.upload()}getRenderPipeline(t){if(this.renderPipeline)return this.updateUniforms(),this.renderPipeline;const e=this.device.createShaderModule({code:"struct Output {\n    @builtin(position) Position: vec4<f32>,\n    @location(0) Normal: vec3<f32>,\n    @location(1) Color: vec3<f32>,\n};\n\nstruct Camera {\n    projection: mat4x4<f32>,\n    view: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> camera: Camera;\n@group(1) @binding(0) var<uniform> model: mat4x4<f32>;\n\n@stage(vertex)\nfn main(\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) color: vec3<f32>) -> Output {\n\n    var output: Output;\n\n    output.Normal = normal;\n    output.Color = color;\n    output.Position = camera.projection * camera.view * model * vec4<f32>(position, 1.0);\n\n    return output;\n}\n"}),i=this.device.createShaderModule({code:"@stage(fragment)\nfn main(\n    @location(0) normal: vec3<f32>,\n    @location(1) color: vec3<f32>) -> @location(0) vec4<f32> {\n\n    return vec4<f32>(color, 1.0);\n}\n"}),s=this.computeUniform();var n;this.uniformBuffer=this.device.createBuffer({size:(n=s.byteLength,n+3&-4),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uniformBuffer.getMappedRange()).set(s),this.uniformBuffer.unmap();const o=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.uniformBindGroup=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]});const r=this.device.createPipelineLayout({bindGroupLayouts:[t.uniformBindGroupLayout,o]});return this.renderPipeline=this.device.createRenderPipeline({layout:r,vertex:{module:e,entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x3"}],arrayStride:36,stepMode:"vertex"}]},fragment:{module:i,entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{frontFace:"cw",cullMode:"none",topology:this._geometry.primitive},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.renderPipeline}updateUniforms(){const t=this.computeUniform();this.device.queue.writeBuffer(this.uniformBuffer,0,t,0,t.length)}computeUniform(){return new Float32Array(u(h(this.position),f(this.rotation)))}}function B(t){return t*(Math.PI/180)}class S{constructor(t,e,i){this.device=e,this.config=Object.assign({fovy:Math.PI/4,near:.1,far:1e3,zoomSpeed:2,distance:5},i),this.zoom=0,this.dragging=!1,this.rotateX=90,this.rotateY=0,this.x=0,this.y=0,this.lastX=0,this.lastY=0,this.limitX=85,this.uniformBuffer=e.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.uniformBindGroup=e.createBindGroup({layout:this.uniformBindGroupLayout,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]}),t.addEventListener("mousedown",(()=>this.onMouseButtonPressed())),t.addEventListener("mouseup",(()=>this.onMouseButtonReleased())),t.addEventListener("wheel",(t=>this.onMouseWheel(t.deltaY))),t.addEventListener("mousemove",(t=>this.onMouseMove(t.clientX,t.clientY))),this.updateUniform()}onMouseButtonPressed(){this.dragging=!0,this.lastX=this.x,this.lastY=this.y}onMouseButtonReleased(){this.dragging=!1}onMouseMove(t,e){this.x=t,this.y=e,this.dragging&&this.drag(this.x,this.y)}onMouseWheel(t){this.zoom+=t<0?-1:1,this.updateUniform()}drag(t,e){let i=90/this.config.height,s=180/this.config.width,n=this.rotateX+i*(e-this.lastY),o=this.rotateY+s*(t-this.lastX);(n<-this.limitX||n>this.limitX)&&(n=this.limitX),this.lastX=t,this.lastY=e,(Math.abs(n-this.rotateX)>.01||Math.abs(o-this.rotateY)>.01)&&(this.rotateX=n,this.rotateY=o),this.updateUniform()}updateUniform(){const e=function(t,e,i,s){const n=1/Math.tan(t/2),o=1/(e-i),r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return r[0]=n/s,r[5]=n,r[10]=(i+e)*o,r[11]=-1,r[14]=2*i*e*o,r}(this.config.fovy,this.config.near,this.config.far,this.config.width/this.config.height),i=t(0,0,-Math.pow(.95,-this.zoom)*this.config.zoomSpeed*this.config.distance),s=t(B(this.rotateX),B(this.rotateY),0),n=u(h(i),f(s)),o=new Float32Array(32);o.set(e,0),o.set(n,16),this.device.queue.writeBuffer(this.uniformBuffer,0,o,0,o.length)}}class U{constructor(t,e){this.device=e,this.context=t.getContext("webgpu"),this.context.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,compositingAlphaMode:"opaque"});const i={size:[t.width,t.height,1],dimension:"2d",format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},s=this.device.createTexture(i);this.depthTextureView=s.createView()}render(t,e,i){const s={colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.83,g:.85,b:.86,a:1},storeOp:"store"}],depthStencilAttachment:{view:this.depthTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},n=this.device.createCommandEncoder(),o=n.beginRenderPass(s),{width:r,height:a}=this.context.canvas;o.setPipeline(e),o.setViewport(0,0,r,a,0,1),o.setScissorRect(0,0,r,a),o.setVertexBuffer(0,t.vertexBuffer),o.setIndexBuffer(t.indexBuffer,"uint16");for(let t=0;t<i.length;t++)o.setBindGroup(t,i[t]);o.drawIndexed(t.indexCount),o.end(),this.device.queue.submit([n.finish()])}}class O{constructor(t,e){this.name=t,this.deltas=[],this.el=e}start(){this._start=window.performance.now()}end(){const t=window.performance.now()-this._start;this.deltas.push(t),this.deltas.length>100&&this.deltas.splice(0,this.deltas.length-100)}render(){const t=this.deltas.reduce(((t,e)=>e+t),0)/this.deltas.length;this.el.innerHTML=`\n            <span class="timer">\n                ${this.name}:\n            </span>\n            <span class="strong">${t.toFixed(3)}</span> ms\n        `}}const M=new class{attach(t){const e=document.createElement("ul");t.appendChild(e),this.el=e,this.timers=[],setInterval((()=>this.render()),200)}createTimer(t){const e=document.createElement("li");this.el.appendChild(e);const i=new O(t,e);return this.timers.push(i),i}render(){this.timers.forEach((t=>t.render()))}};class C{constructor(t,e){this.buffer=t,this.offset=e}get x(){return this.buffer[this.offset]}set x(t){this.buffer[this.offset]=t}get y(){return this.buffer[this.offset+1]}set y(t){this.buffer[this.offset+1]=t}get z(){return this.buffer[this.offset+2]}set z(t){this.buffer[this.offset+2]=t}}class G{constructor(t,e,i){this.id=t,this.buffer=e,this.offset=i}get position(){const t=this.offset+G.positionOffset;return new C(this.buffer,t)}set position(t){const e=this.offset+G.positionOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}get normal(){const t=this.offset+G.normalOffset;return new C(this.buffer,t)}set normal(t){const e=this.offset+G.normalOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}get color(){const t=this.offset+G.colorOffset;return new C(this.buffer,t)}set color(t){const e=this.offset+G.colorOffset;this.buffer[e]=t.x,this.buffer[e+1]=t.y,this.buffer[e+2]=t.z}}G.positionOffset=0,G.normalOffset=3,G.colorOffset=6,G.components=9;class _{constructor(t){this.buffer=new Float32Array(t*G.components),this.count=0}add(t){const e=this.count,i=this.count*G.components,s=new G(e,this.buffer,i);s.position=t.position,s.normal=t.normal,s.color=t.color,this.count++}get(t){return new G(t,this.buffer,t*G.components)}forEach(t){for(let e=0;e<this.count;e++)t(new G(e,this.buffer,e*G.components))}}class z{constructor(t,e,i){this.vertices=e,this.defaultIndices=i,this.topology=function(t,e){const i=e.length/3,s=new Array(t.count),n={},o=[],r=[],a=(t,e)=>{s[t]||(s[t]=[]),s[t].push(e)};for(let t=0;t<i;t++){const i={a:e[3*t],b:e[3*t+1],c:e[3*t+2]};a(i.a,t),a(i.b,t),a(i.c,t);const s=[{start:Math.min(i.a,i.b),end:Math.max(i.a,i.b)},{start:Math.min(i.b,i.c),end:Math.max(i.b,i.c)},{start:Math.min(i.c,i.a),end:Math.max(i.c,i.a)}];o.push(i);for(let e of s){const i=`${e.start}-${e.end}`;n[i]?r[n[i]].triangles.push(t):(r.push({start:e.start,end:e.end,triangles:[t]}),n[i]=r.length-1)}}return{triangles:o,edges:r}}(e,i),this.primitive="triangle-list",this.vertexComponents=6,this.vertexPositionOffset=0,this.vertexNormalOffset=3,this.device=t,this._wireframe=!1,this.defaultIndexBuffer=t.createBuffer({size:T(this.defaultIndices.byteLength),usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Uint16Array(this.defaultIndexBuffer.getMappedRange()).set(this.defaultIndices),this.defaultIndexBuffer.unmap(),this.vertexBuffer=t.createBuffer({size:T(this.vertices.buffer.byteLength),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(this.vertices.buffer),this.vertexBuffer.unmap()}get indexBuffer(){return this.wireframe?this.wireframeIndexBuffer:this.defaultIndexBuffer}get indexCount(){return this.wireframe?this.wireframeIndices.length:this.defaultIndices.length}set wireframe(t){this._wireframe!==t&&(this._wireframe=t,t?(this.wireframeIndices||(this.wireframeIndices=function(t){const e=new Uint16Array(2*t.edges.length);let i=0;for(let s of t.edges)e[i]=s.start,e[i+1]=s.end,i+=2;return e}(this.topology),this.wireframeIndexBuffer=this.device.createBuffer({size:T(this.wireframeIndices.byteLength),usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST})),this.device.queue.writeBuffer(this.wireframeIndexBuffer,0,this.wireframeIndices,0,this.wireframeIndices.length),this.primitive="line-list"):(this.device.queue.writeBuffer(this.defaultIndexBuffer,0,this.defaultIndices,0,this.defaultIndices.length),this.primitive="triangle-list"))}get wireframe(){return this._wireframe}upload(){this.device.queue.writeBuffer(this.vertexBuffer,0,this.vertices.buffer,0,this.vertices.buffer.length)}}function E(e,i,s,n,o){const r=i/n,a=s/n;g.info(`plane geometry: size=(**${i}**, **${s}**) divisions=(**${n}**, **${o}**)`);const c=2*o*n,h=new _((o+1)*(n+1)),f=new Uint16Array(3*c);let u=0;for(let e=0;e<=o;e++)for(let i=0;i<=n;i++){if(h.add({position:t(i*r,0,e*a),normal:t(0,1,0),color:t(0,1,0)}),0==e)continue;const s=i+e*(n+1);i>0&&(f.set([s-(n+1),s-1,s],u),u+=3),i<n&&(f.set([s-(n+1),s,s-n],u),u+=3)}return new z(e,h,f)}function T(t){return t+3&-4}var $;class I{constructor(e,i){this.canvas=e,this.device=i,this.stopped=!1,this.camera=new S(e,i,{width:e.width,height:e.height}),this.renderer=new U(e,i),this.solver=new y({deltaTime:1/60,subSteps:15,stretchCompliance:0,bendCompliance:.3,relaxation:.2,method:v.GaussSeidel});const s=E(this.device,10,10,30,30);this.cloth=new x(this.device,s,t(-5,0,0))}run(){return t=this,e=void 0,s=function*(){this.stopped=!1;const t=M.createTimer("tick"),e=M.createTimer("physic");let i=0;return new Promise(((s,n)=>{const o=n=>{if(this.stopped)return void s();i=n,t.start(),e.start(),this.solver.solve(this.cloth),e.end();const r=this.cloth.getRenderPipeline(this.camera);r&&this.renderer.render(this.cloth.geometry,r,[this.camera.uniformBindGroup,this.cloth.uniformBindGroup]),t.end(),window.requestAnimationFrame(o)};window.requestAnimationFrame(o)}))},new((i=void 0)||(i=Promise))((function(n,o){function r(t){try{c(s.next(t))}catch(t){o(t)}}function a(t){try{c(s.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,a)}c((s=s.apply(t,e||[])).next())}));var t,e,i,s}stop(){this.stopped=!0}}class A{constructor(t,e){this.config=e,this.device=t;const i=t.createShaderModule({code:"struct Config {\n    particleCount: f32,\n}\n\nstruct Particle {\n    position: vec3<f32>,\n    velocity: vec3<f32>,\n    inverseMass: f32,\n}\n\n@group(0) @binding(0) var<storage, read> inputParticles: array<Particle>;\n@group(0) @binding(1) var<storage, write> outputParticles: array<Particle>;\n@group(1) @binding(0) var<uniform> config: Config;\n\n@stage(compute) @workgroup_size(8, 1)\nfn main(@builtin(global_invocation_id) global_id : vec3<u32>) {\n    // Guard against out-of-bounds work group sizes\n    if (global_id.x >= u32(config.particleCount)) {\n        return;\n    }\n\n    var input = inputParticles[global_id.x].position;\n    outputParticles[global_id.x].position = vec3<f32>(f32(global_id.x), f32(global_id.y), input.z);\n}\n"});this.configBuffer=t.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.gpuInputParticlesBuffer=t.createBuffer({size:D(9e5),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.gpuOutputParticlesBuffer=t.createBuffer({size:D(9e5),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC}),this.pipeline=t.createComputePipeline({layout:"auto",compute:{module:i,entryPoint:"main"}}),this.particlesBindGroup=t.createBindGroup({label:"particles-bind-group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.gpuInputParticlesBuffer}},{binding:1,resource:{buffer:this.gpuOutputParticlesBuffer}}]}),this.configBindGroup=t.createBindGroup({label:"config-bind-group",layout:this.pipeline.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:this.configBuffer}}]})}solve(t){const e=this._config.deltaTime/this._config.subSteps,i=t.particles.count,s=new Float32Array([i]);this.device.queue.writeBuffer(this.gpuInputParticlesBuffer,0,t.particles.buffer,0,t.particles.buffer.length),this.device.queue.writeBuffer(this.configBuffer,0,s,0,s.length);const n=this.device.createCommandEncoder();for(let t=0;t<this.config.subSteps;t++)this.semiExplicitEuler(n,e,i),this.applyConstraints(e),this.updatePositionsAndVelocities(e);const o=D(4*t.particles.buffer.length),r=this.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});n.copyBufferToBuffer(this.gpuOutputParticlesBuffer,0,r,0,o);const a=n.finish();this.device.queue.submit([a]),r.mapAsync(GPUMapMode.READ).then((()=>{const t=r.getMappedRange(),e=new Float32Array(t);console.table(e);for(let t=0;t<e.length/9;t++){const i=8*t;console.log(`${t} ${i} - (${e[i]}, ${e[i+1]}, ${e[i+2]})`)}}))}semiExplicitEuler(t,e,i){const s=t.beginComputePass();s.setPipeline(this.pipeline),s.setBindGroup(0,this.particlesBindGroup),s.setBindGroup(1,this.configBindGroup),s.dispatchWorkgroups(i,1),s.end()}applyConstraints(t){}updatePositionsAndVelocities(t){}set config(t){const e=Object.assign(Object.assign({},A.defaultConfig),t);Object.keys(e).forEach((t=>{const i=this._config[t],s=e[t];s!==i&&g.info(`${t}: **${m(s)}**`)})),this._config=e}get config(){return this._config}}function D(t){return t+3&-4}A.defaultConfig={deltaTime:1/60,subSteps:10},function(t){t.CPU="cpu",t.GPU="gpu"}($||($={}));class L{constructor(t,e){this.app=e,this.device=t,this.renderNeeded=!0,this.config={paused:!0,solverType:$.CPU,cpuSolver:{deltaTime:1/60,subSteps:15,stretchCompliance:0,bendCompliance:.3,relaxation:.2,method:v.GaussSeidel},gpuSolver:{subSteps:10},cloth:{width:10,height:10,widthDivisions:40,heightDivisions:40}}}attach(t){this.el=t,this.updateApp(this.config,!0),setInterval((()=>this.run()),50),window.addEventListener("keypress",(t=>{switch(t.code){case"Space":this.togglePlay();break;case"KeyW":this.app.cloth.wireframe=!this.app.cloth.wireframe,g.info(`wireframe mode **${this.app.cloth.wireframe?"enabled":"disabled"}**`)}}))}run(){if(!this.renderNeeded)return;this.el.innerHTML=this.render(),this.renderNeeded=!1;const t=document.getElementById("play"),e=document.getElementById("restart"),i=document.getElementById("apply");t.addEventListener("click",(t=>{console.log("click!"),t.preventDefault(),this.togglePlay()})),e.addEventListener("click",(t=>{t.preventDefault(),this.restartSimulation()})),i.addEventListener("click",(t=>{t.preventDefault(),this.apply()}))}render(){return`\n            <form>\n                <div>\n                    <div class="column">\n                        <label for="cloth-width">\n                            <span>width</span>\n                            <input type="number" id="cloth-width" name="cloth-width"\n                                value=${this.config.cloth.width}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-height">\n                            <span>height</span>\n                            <input type="number" id="cloth-height" name="cloth-height"\n                                value=${this.config.cloth.height}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-width-divisions">\n                            <span>width-division</span>\n                            <input type="number" id="cloth-width-divisions" name="cloth-width-divisions"\n                                value=${this.config.cloth.widthDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-height-divisions">\n                            <span>height-division</span>\n                            <input type="number" id="cloth-height-divisions" name="cloth-height-divisions"\n                                value=${this.config.cloth.heightDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="solver-type">\n                            <span>solver type</span>\n                            <select id="solver-type" name="solver-type">\n                                <option ${this.config.solverType===$.CPU?"selected":""} value=${$.CPU}>CPU</option>\n                                <option ${this.config.solverType===$.GPU?"selected":""} value=${$.GPU}>GPU</option>\n                            </select>\n                        </label>\n                    </div>\n\n                    ${this.config.solverType===$.CPU?this.renderCPUSolverForm():this.renderGPUSolverForm()}\n                </div>\n\n                <div class="row">\n                    <button id="play">${this.config.paused?"Play":"Pause"}</button>\n                    <button id="restart">Restart</button>\n                    <button id="apply">Apply</button>\n                </div>\n            </form>\n        `}renderCPUSolverForm(){return`\n            <div class="column">\n                <label for="cpu-method">\n                    <span>method</span>\n                    <select id="cpu-method" name="cpu-method">\n                        <option ${this.config.cpuSolver.method===v.Jacobi?"selected":""} value=${v.Jacobi}>Jacobi</option>\n                        <option ${this.config.cpuSolver.method===v.GaussSeidel?"selected":""} value=${v.GaussSeidel}>Gauss-Seidel</option>\n                    </select>\n                </label>\n                <label for="cpu-sub-steps">\n                    <span>sub-steps</span>\n                    <input type="number" id="cpu-sub-steps" name="cpu-sub-steps"\n                        value=${this.config.cpuSolver.subSteps}\n                        step=1\n                        min=1\n                        max=500 />\n                </label>\n\n                <label for="cpu-stretch-compliance">\n                    <span>stretch compliance</span>\n                    <input type="number" id="cpu-stretch-compliance" name="cpu-stretch-compliance"\n                        value=${this.config.cpuSolver.stretchCompliance}\n                        step=0.1\n                        min=0\n                        max=1 />\n                </label>\n\n                <label for="cpu-bend-compliance">\n                    <span>bend compliance</span>\n                    <input type="number" id="cpu-bend-compliance" name="cpu-bend-compliance"\n                        value=${this.config.cpuSolver.bendCompliance}\n                        step=0.1\n                        min=0\n                        max=1 />\n                </label>\n\n                <label for="cpu-relaxation">\n                    <span>relaxation</span>\n                    <input type="number" id="cpu-relaxation" name="cpu-relaxation"\n                        value=${this.config.cpuSolver.relaxation}\n                        step=0.05\n                        min=0\n                        max=2 />\n                </label>\n            </div>\n        `}renderGPUSolverForm(){return`\n            <div class="column">\n                <label for="gpu-sub-steps">\n                    <span>sub-steps</span>\n                    <input type="number" id="gpu-sub-steps" name="gpu-sub-steps"\n                        value=${this.config.gpuSolver.subSteps}\n                        step=1\n                        min=1\n                        max=500 />\n                </label>\n            </div>\n        `}updateApp(t,e=!1){const i=t.solverType!==this.config.solverType,s=t.cloth.width!==this.config.cloth.width||t.cloth.height!==this.config.cloth.height||t.cloth.widthDivisions!==this.config.cloth.widthDivisions||t.cloth.heightDivisions!==this.config.cloth.heightDivisions;(e||s)&&(g.info("resetting the simulation with a new cloth geometry..."),this.app.cloth.geometry=E(this.device,t.cloth.width,t.cloth.height,t.cloth.widthDivisions,t.cloth.heightDivisions)),t.solverType===$.CPU?e||i?(g.info("switching to CPU solver..."),this.app.solver=new y(t.cpuSolver)):(console.log(),this.app.solver.config=t.cpuSolver):e||i?(g.info("switching to GPU solver..."),this.app.solver=new A(this.device,t.gpuSolver)):this.app.solver.config=t.gpuSolver}buildConfiguration(){const t=new FormData(this.el.querySelector("form")),e=Object.assign(Object.assign({},this.config),{solverType:t.get("solver-type"),cloth:{width:parseFloat(t.get("cloth-width")),height:parseFloat(t.get("cloth-height")),widthDivisions:parseInt(t.get("cloth-width-divisions")),heightDivisions:parseInt(t.get("cloth-height-divisions"))}});return e.solverType===$.CPU&&(e.cpuSolver=Object.assign(Object.assign({},this.config.cpuSolver),{subSteps:parseInt(t.get("cpu-sub-steps")),stretchCompliance:parseFloat(t.get("cpu-stretch-compliance")),bendCompliance:parseFloat(t.get("cpu-bend-compliance")),relaxation:parseFloat(t.get("cpu-relaxation")),method:t.get("cpu-method")})),e.solverType===$.GPU&&(e.gpuSolver=Object.assign(Object.assign({},this.config.gpuSolver),{subSteps:parseInt(t.get("gpu-sub-steps"))})),this.renderNeeded=!0,e}apply(){const t=this.buildConfiguration();this.updateApp(t),this.config=t}restartSimulation(){this.app.cloth.geometry=E(this.device,this.config.cloth.width,this.config.cloth.height,this.config.cloth.widthDivisions,this.config.cloth.heightDivisions)}togglePlay(){this.config.paused=!this.config.paused,this.app.solver.paused=this.config.paused}}(function(){return t=this,e=void 0,s=function*(){const t=navigator.gpu;if(!t)throw new Error("WebGPU is not supported on this browser.");const e=yield t.requestAdapter(),i=yield e.requestDevice(),s=document.getElementById("app");s.width=1e3,s.height=512;const n=new I(s,i),o=new L(i,n);return g.attach(document.getElementById("logger")),M.attach(document.getElementById("monitor")),o.attach(document.getElementById("controller")),n.run()},new((i=void 0)||(i=Promise))((function(n,o){function r(t){try{c(s.next(t))}catch(t){o(t)}}function a(t){try{c(s.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,a)}c((s=s.apply(t,e||[])).next())}));var t,e,i,s})().then((()=>g.info("done"))).catch((t=>console.error(t.toString()+"\n"+t.stack)))}();