!function(){"use strict";function t(t,e,i){return{x:t,y:e,z:i}}function e(t,e){return t.x+=e.x,t.y+=e.y,t.z+=e.z,t}function i(t,e){return{x:t.x-e.x,y:t.y-e.y,z:t.z-e.z}}function n(t,e){const i=t.x,n=t.y,s=t.z,o=e.x,r=e.y,a=e.z;return{x:n*a-s*r,y:s*o-i*a,z:i*r-n*o}}function s(t,e){const i=t.x,n=t.y,s=t.z,o=e.x,r=e.y,a=e.z;return t.x=n*a-s*r,t.y=s*o-i*a,t.z=i*r-n*o,t}function o(t){const e=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return e[12]=t.x,e[13]=t.y,e[14]=t.z,e}function r(t){return function(t,e){const i=Math.sin(e),n=Math.cos(e),s=t[0],o=t[1],r=t[2],a=t[3],c=t[4],h=t[5],l=t[6],u=t[7];return t[0]=s*n+c*i,t[1]=o*n+h*i,t[2]=r*n+l*i,t[3]=a*n+u*i,t[4]=c*n-s*i,t[5]=h*n-o*i,t[6]=l*n-r*i,t[7]=u*n-a*i,t}(function(t,e){const i=Math.sin(e),n=Math.cos(e),s=t[0],o=t[1],r=t[2],a=t[3],c=t[8],h=t[9],l=t[10],u=t[11];return t[0]=s*n-c*i,t[1]=o*n-h*i,t[2]=r*n-l*i,t[3]=a*n-u*i,t[8]=s*i+c*n,t[9]=o*i+h*n,t[10]=r*i+l*n,t[11]=a*i+u*n,t}(function(t,e){const i=Math.sin(e),n=Math.cos(e),s=t[4],o=t[5],r=t[6],a=t[7],c=t[8],h=t[9],l=t[10],u=t[11];return t[4]=s*n+c*i,t[5]=o*n+h*i,t[6]=r*n+l*i,t[7]=a*n+u*i,t[8]=c*n-s*i,t[9]=h*n-o*i,t[10]=l*n-r*i,t[11]=u*n-a*i,t}([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t.x),t.y),t.z)}function a(t,e){const i=t[0],n=t[1],s=t[2],o=t[3],r=t[4],a=t[5],c=t[6],h=t[7],l=t[8],u=t[9],d=t[10],f=t[11],g=t[12],p=t[13],m=t[14],v=t[15];let y=e[0],b=e[1],w=e[2],P=e[3];return t[0]=y*i+b*r+w*l+P*g,t[1]=y*n+b*a+w*u+P*p,t[2]=y*s+b*c+w*d+P*m,t[3]=y*o+b*h+w*f+P*v,y=e[4],b=e[5],w=e[6],P=e[7],t[4]=y*i+b*r+w*l+P*g,t[5]=y*n+b*a+w*u+P*p,t[6]=y*s+b*c+w*d+P*m,t[7]=y*o+b*h+w*f+P*v,y=e[8],b=e[9],w=e[10],P=e[11],t[8]=y*i+b*r+w*l+P*g,t[9]=y*n+b*a+w*u+P*p,t[10]=y*s+b*c+w*d+P*m,t[11]=y*o+b*h+w*f+P*v,y=e[12],b=e[13],w=e[14],P=e[15],t[12]=y*i+b*r+w*l+P*g,t[13]=y*n+b*a+w*u+P*p,t[14]=y*s+b*c+w*d+P*m,t[15]=y*o+b*h+w*f+P*v,t}class c{constructor(t,e){this.toString=()=>`(${this.x}, ${this.y}, ${this.z})`,this.buffer=t,this.offset=e}get x(){return this.buffer[this.offset]}set x(t){this.buffer[this.offset]=t}get y(){return this.buffer[this.offset+1]}set y(t){this.buffer[this.offset+1]=t}get z(){return this.buffer[this.offset+2]}set z(t){this.buffer[this.offset+2]=t}}c.alignedLength=4;class h{constructor(t,e,i){this.id=t,this.data=e,this.offset=i}get position(){return new c(this.data.positions,this.offset*c.alignedLength)}set position(t){this.data.positions[this.offset*c.alignedLength]=t.x,this.data.positions[this.offset*c.alignedLength+1]=t.y,this.data.positions[this.offset*c.alignedLength+2]=t.z}get estimatedPosition(){return new c(this.data.estimatedPositions,this.offset*c.alignedLength)}set estimatedPosition(t){this.data.estimatedPositions[this.offset*c.alignedLength]=t.x,this.data.estimatedPositions[this.offset*c.alignedLength+1]=t.y,this.data.estimatedPositions[this.offset*c.alignedLength+2]=t.z}get deltaPosition(){return new c(this.data.deltaPositions,this.offset*c.alignedLength)}set deltaPosition(t){this.data.deltaPositions[this.offset*c.alignedLength]=t.x,this.data.deltaPositions[this.offset*c.alignedLength+1]=t.y,this.data.deltaPositions[this.offset*c.alignedLength+2]=t.z}get velocity(){return new c(this.data.velocities,this.offset*c.alignedLength)}set velocity(t){this.data.velocities[this.offset*c.alignedLength]=t.x,this.data.velocities[this.offset*c.alignedLength+1]=t.y,this.data.velocities[this.offset*c.alignedLength+2]=t.z}get inverseMass(){return this.data.inverseMasses[this.offset]}set inverseMass(t){this.data.inverseMasses[this.offset]=t}get constraintCount(){return this.data.constraintCounts[this.offset]}set constraintCount(t){this.data.constraintCounts[this.offset]=t}}class l{constructor(t,e){this.device=t,this.data={positions:new Float32Array(e*c.alignedLength),velocities:new Float32Array(e*c.alignedLength),estimatedPositions:new Float32Array(e*c.alignedLength),deltaPositions:new Float32Array(e*c.alignedLength),inverseMasses:new Float32Array(e),constraintCounts:new Float32Array(e)},this.estimatedPositionBuffer=this.device.createBuffer({label:"estimated-position",size:u(this.data.estimatedPositions.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.velocityBuffer=this.device.createBuffer({label:"velocity",size:u(this.data.velocities.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),this.inverseMassBuffer=this.device.createBuffer({label:"inverse-masses",size:u(this.data.inverseMasses.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.count=0,this.max=e}upload(){this.device.queue.writeBuffer(this.estimatedPositionBuffer,0,this.data.estimatedPositions,0,this.count),this.device.queue.writeBuffer(this.velocityBuffer,0,this.data.velocities,0,this.count),this.device.queue.writeBuffer(this.inverseMassBuffer,0,this.data.inverseMasses,0,this.count)}add(t){if(this.count>=this.max)throw new Error("max number of particles reached");const e=new h(this.count,this.data,this.count);e.position=t.position,e.estimatedPosition=t.estimatedPosition,e.deltaPosition=t.deltaPosition,e.velocity=t.velocity,e.inverseMass=t.inverseMass,this.count++}get(t){return new h(t,this.data,t)}forEach(t){for(let e=0;e<this.count;e++)t(new h(e,this.data,e))}}function u(t){return t+3&-4}class d{constructor(t,e){this.data=t,this.offset=e}get p1(){return this.data.affectedParticles[2*this.offset]}set p1(t){this.data.affectedParticles[2*this.offset]=t}get p2(){return this.data.affectedParticles[2*this.offset+1]}set p2(t){this.data.affectedParticles[2*this.offset+1]=t}get restValue(){return this.data.restValues[this.offset]}set restValue(t){this.data.restValues[this.offset]=t}get compliance(){return this.data.compliances[this.offset]}set compliance(t){this.data.compliances[this.offset]=t}unref(){return{p1:this.p1,p2:this.p2,compliance:this.compliance,restValue:this.restValue}}}class f{constructor(t,e){this.device=t,this.data={restValues:new Float32Array(e),compliances:new Float32Array(e),affectedParticles:new Float32Array(2*e)},this.colors=new Uint32Array(3200),this.adjacency=[],this.count=0,this.colorCount=0,this.maxConstraints=e,this.restValueBuffer=this.device.createBuffer({label:"rest-values",size:g(this.data.restValues.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.complianceBuffer=this.device.createBuffer({label:"compliances",size:g(this.data.compliances.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.affectedParticleBuffer=this.device.createBuffer({label:"affected-particles",size:g(this.data.affectedParticles.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.colorBuffer=this.device.createBuffer({label:"colors",size:g(this.colors.byteLength),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}upload(){this.color(),this.device.queue.writeBuffer(this.restValueBuffer,0,this.data.restValues,0,this.count),this.device.queue.writeBuffer(this.complianceBuffer,0,this.data.compliances,0,this.count),this.device.queue.writeBuffer(this.affectedParticleBuffer,0,this.data.affectedParticles,0,2*this.count),this.device.queue.writeBuffer(this.colorBuffer,0,this.colors,0,64*this.colorCount)}add(t,e,i){if(this.count>=this.maxConstraints)throw new Error("max number of constraints reached");const n=new d(this.data,this.count);n.compliance=i,n.restValue=function(t,e){const i=t.x,n=t.y,s=t.z,o=e.x,r=e.y,a=e.z;return Math.sqrt((i-o)*(i-o)+(n-r)*(n-r)+(s-a)*(s-a))}(t.position,e.position),n.p1=t.id,n.p2=e.id,this.addAdjacency(t.id,e.id),this.addAdjacency(e.id,t.id),this.count++}get(t){return new d(this.data,t)}set(t,e){if(t<0||t>=this.count)throw new Error("out of bound");const i=new d(this.data,t);i.compliance=e.compliance,i.restValue=e.restValue,i.p1=e.p1,i.p2=e.p2}forEach(t){for(let e=0;e<this.count;e++)t(new d(this.data,e))}addAdjacency(t,e){if(t>this.adjacency.length-1)for(let e=this.adjacency.length;e<=t;e++)this.adjacency.push([]);this.adjacency[t].push(e)}color(){const t=[],e=new Array(this.count).fill(!1),i=new Array(this.adjacency.length).fill(!1);let n=this.count;for(;n;){if(t.length>=50)throw new Error("max number of colors reached");const s=[];i.fill(!1);for(let t=0;t<this.count;t++){if(e[t])continue;const o=this.data.affectedParticles[2*t],r=this.data.affectedParticles[2*t+1];i[o]||i[r]||(s.push(t),e[t]=!0,n--,i[o]=!0,i[r]=!0)}t.push(s)}const s=new f(this.device,this.maxConstraints);s.count=this.count;let o=0;for(let e=0;e<t.length;e++){this.colors[64*e]=o;for(let i=0;i<t[e].length;i++)s.set(o,this.get(t[e][i])),o++;this.colors[64*e+1]=o-this.colors[64*e]}this.data.restValues=s.data.restValues,this.data.compliances=s.data.compliances,this.data.affectedParticles=s.data.affectedParticles,this.colorCount=t.length}}function g(t){return t+3&-4}const p=new class{constructor(){this.pending=[]}attach(t){this.el=t,setInterval((()=>this.flush()),100)}flush(){this.pending.length&&(this.pending.forEach((t=>{const e=document.createElement("p"),i=t.date.toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"});let n=t.message;n=this.replaceCarriageReturns(n),n=this.replaceStrongMarkers(n),e.innerHTML=`<span class="date">${i}&nbsp&nbsp</span><span class="message">${n}</span>`,this.el.appendChild(e)})),this.el.scrollTop=this.el.scrollHeight,this.pending=[])}replaceCarriageReturns(t){return t.replace(/\n/g,"<br/>")}replaceStrongMarkers(t){const e="**";let i="";for(;;){const n=t.indexOf(e);if(-1===n)return i+t;const s=t.slice(n+e.length).indexOf(e);if(-1===s)return i+t;i+=t.slice(0,n),i+=`<span class="strong">${t.slice(n+e.length,n+e.length+s)}</span>`,t=t.slice(n+e.length+s+e.length)}}info(t){this.pending.push({date:new Date,message:t})}warn(t){this.pending.push({date:new Date,message:t})}error(t){this.pending.push({date:new Date,message:t})}};class m{constructor(t,e,i,n,s){this._config=Object.assign(Object.assign({},m.defaultConfig),i),this.device=t,this.geometry=e,this.updated=!1,this._position={x:0,y:0,z:0},this._rotation={x:0,y:0,z:0},n&&(this.position=n),s&&(this.rotation=s),this.renderPipeline=null}set geometry(t){this._geometry=t,this.particles=v(this.device,this._geometry,this._config.unit,this._config.density),this.constraints=y(this.device,this._geometry,this.particles,this._config.stretchCompliance,this._config.bendCompliance),p.info(`vertices: **${this._geometry.vertices.count}**`),p.info(`triangles: **${this._geometry.topology.triangles.length}**`),p.info(`edges: **${this._geometry.topology.edges.length}**`),p.info(`constraints: **${this.constraints.count}**`)}get geometry(){return this._geometry}set config(t){const e=Object.assign(Object.assign({},m.defaultConfig),t),i=e.unit!==this._config.unit||e.density!==this._config.density,n=e.stretchCompliance!==this._config.stretchCompliance||e.bendCompliance!==this._config.bendCompliance||e.density;(n||i)&&(Object.keys(e).forEach((t=>{const i=this._config[t],n=e[t];var s;n!==i&&p.info(`${t}: **${s=n,"object"==typeof s?JSON.stringify(s):s.toString()}**`)})),i&&(this.particles=v(this.device,this._geometry,e.unit,e.density)),n&&(this.constraints=y(this.device,this._geometry,this.particles,e.stretchCompliance,e.bendCompliance)),this._config=e)}get config(){return this._config}set position(t){this._position=t,this.updated=!0}get position(){return this._position}set rotation(t){this._rotation=t,this.updated=!0}get rotation(){return this._rotation}updatePositionsAndNormals(){this._geometry.vertices.forEach((t=>{const e=this.particles.get(t.id);t.position=e.position,t.normal={x:0,y:0,z:0}}));for(let o of this._geometry.topology.triangles){const r=this._geometry.vertices.get(o.a),a=this._geometry.vertices.get(o.b),c=this._geometry.vertices.get(o.c),h=(t=n(i(a.position,r.position),i(c.position,r.position)),s=1e4,t.x*=s,t.y*=s,t.z*=s,t);e(r.normal,h),e(a.normal,h),e(c.normal,h)}var t,s;this._geometry.upload()}getRenderPipeline(t){if(this.renderPipeline)return this.updateUniforms(),this.renderPipeline;const e=this.device.createShaderModule({code:"struct Output {\n    @builtin(position) Position: vec4<f32>,\n    @location(0) Normal: vec3<f32>,\n};\n\nstruct Camera {\n    projection: mat4x4<f32>,\n    view: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> camera: Camera;\n@group(1) @binding(0) var<uniform> model: mat4x4<f32>;\n\n@stage(vertex)\nfn main(@location(0) position: vec3<f32>, @location(1) normal: vec3<i32>) -> Output {\n    var output: Output;\n\n    output.Normal = normalize(vec3<f32>(normal) / 10000.0);\n    output.Position = camera.projection * camera.view * model * vec4<f32>(position, 1.0);\n\n    return output;\n}\n"}),i=this.device.createShaderModule({code:"@stage(fragment)\nfn main(@location(0) normal: vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(normal, 1.0);\n}\n"}),n=this.computeUniform();var s;this.uniformBuffer=this.device.createBuffer({size:(s=n.byteLength,s+3&-4),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uniformBuffer.getMappedRange()).set(n),this.uniformBuffer.unmap();const o=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.uniformBindGroup=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]});const r=this.device.createPipelineLayout({bindGroupLayouts:[t.uniformBindGroupLayout,o]});return this.renderPipeline=this.device.createRenderPipeline({layout:r,vertex:{module:e,entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:16,stepMode:"vertex"},{attributes:[{shaderLocation:1,offset:0,format:"sint32x3"}],arrayStride:16,stepMode:"vertex"}]},fragment:{module:i,entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{frontFace:"cw",cullMode:"none",topology:"triangle-list"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.renderPipeline}updateUniforms(){const t=this.computeUniform();this.device.queue.writeBuffer(this.uniformBuffer,0,t,0,t.length)}computeUniform(){return new Float32Array(a(o(this.position),r(this.rotation)))}}function v(t,e,n,o){const r=new l(t,e.vertices.count);e.vertices.forEach((t=>{r.add({position:t.position,velocity:{x:0,y:0,z:0},estimatedPosition:{x:0,y:0,z:0},deltaPosition:{x:0,y:0,z:0},inverseMass:0,constraintCount:0})}));for(let t of e.topology.triangles){const e=r.get(t.a),c=r.get(t.b),h=r.get(t.c),l=1/(n*(.5*(a=s(i(c.position,e.position),i(h.position,e.position)),Math.sqrt(function(t){const e=t.x,i=t.y,n=t.z;return e*e+i*i+n*n}(a))))*o)/3;e.inverseMass+=l,c.inverseMass+=l,h.inverseMass+=l}var a;return r.forEach((t=>{0===t.position.z&&(t.inverseMass=0)})),r}function y(t,e,i,n,s){const o=[];for(let t of e.topology.edges)o.push({compliance:n,p1:t.start,p2:t.end});for(let t of e.topology.edges){if(1==t.triangles.length)continue;if(2!=t.triangles.length)throw new Error(`Non-manifold mesh: ${t.start}-${t.end} shared with ${t.triangles.length} triangles`);const i=e.topology.triangles[t.triangles[0]],n=e.topology.triangles[t.triangles[1]];let r,a;r=i.a!=t.start&&i.a!=t.end?i.a:i.b!=t.start&&i.b!=t.end?i.b:i.c,a=n.a!=t.start&&n.a!=t.end?n.a:n.b!=t.start&&n.b!=t.end?n.b:n.c,o.push({compliance:s,p1:r,p2:a})}!function(t){for(let e=t.length-1;e>=1;e--){const i=Math.floor(Math.random()*(e+1)),n=t[i];t[i]=t[e],t[e]=n}}(o);const r=new f(t,o.length);for(let t of o)r.add(i.get(t.p1),i.get(t.p2),t.compliance);return r}function b(t){return t*(Math.PI/180)}m.defaultConfig={unit:.01,density:.27,stretchCompliance:0,bendCompliance:.3};class w{constructor(t,e,i){this.device=e,this.config=Object.assign({fovy:Math.PI/4,near:1e-4,far:1e3,zoomSpeed:2,distance:5},i),this.zoom=0,this.dragging=!1,this.rotateX=90,this.rotateY=0,this.x=0,this.y=0,this.lastX=0,this.lastY=0,this.limitX=85,this.uniformBuffer=e.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.uniformBindGroup=e.createBindGroup({layout:this.uniformBindGroupLayout,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]}),t.addEventListener("mousedown",(()=>this.onMouseButtonPressed())),t.addEventListener("mouseup",(()=>this.onMouseButtonReleased())),t.addEventListener("wheel",(t=>this.onMouseWheel(t.deltaY))),t.addEventListener("mousemove",(t=>this.onMouseMove(t.clientX,t.clientY))),this.updateUniform()}onMouseButtonPressed(){this.dragging=!0,this.lastX=this.x,this.lastY=this.y}onMouseButtonReleased(){this.dragging=!1}onMouseMove(t,e){this.x=t,this.y=e,this.dragging&&this.drag(this.x,this.y)}onMouseWheel(t){this.zoom+=t<0?-1:1,this.updateUniform()}drag(t,e){let i=90/this.config.height,n=180/this.config.width,s=this.rotateX+i*(e-this.lastY),o=this.rotateY+n*(t-this.lastX);(s<-this.limitX||s>this.limitX)&&(s=this.limitX),this.lastX=t,this.lastY=e,(Math.abs(s-this.rotateX)>.01||Math.abs(o-this.rotateY)>.01)&&(this.rotateX=s,this.rotateY=o),this.updateUniform()}updateUniform(){const e=function(t,e,i,n){const s=1/Math.tan(t/2),o=1/(e-i),r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return r[0]=s/n,r[5]=s,r[10]=(i+e)*o,r[11]=-1,r[14]=2*i*e*o,r}(this.config.fovy,this.config.near,this.config.far,this.config.width/this.config.height),i=t(0,0,-Math.pow(.95,-this.zoom)*this.config.zoomSpeed*this.config.distance),n=t(b(this.rotateX),b(this.rotateY),0),s=a(o(i),r(n)),c=new Float32Array(32);c.set(e,0),c.set(s,16),this.device.queue.writeBuffer(this.uniformBuffer,0,c,0,c.length)}}class P{constructor(t,e){this.device=e,this.context=t.getContext("webgpu"),this.context.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,compositingAlphaMode:"opaque"});const i={size:[t.width,t.height,1],dimension:"2d",format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},n=this.device.createTexture(i);this.depthTextureView=n.createView()}render(t,e,i,n){const s={colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.83,g:.85,b:.86,a:1},storeOp:"store"}],depthStencilAttachment:{view:this.depthTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},o=t.beginRenderPass(s),{width:r,height:a}=this.context.canvas;o.setPipeline(i),o.setViewport(0,0,r,a,0,1),o.setScissorRect(0,0,r,a),o.setVertexBuffer(0,e.positionBuffer),o.setVertexBuffer(1,e.normalBuffer),o.setIndexBuffer(e.indexBuffer,"uint32");for(let t=0;t<n.length;t++)o.setBindGroup(t,n[t]);o.drawIndexed(e.indexes.length),o.end()}}class B{constructor(t,e){this.name=t,this.deltas=[],this.el=e}start(){this._start=window.performance.now()}end(){const t=window.performance.now()-this._start;this.deltas.push(t),this.deltas.length>5&&this.deltas.splice(0,this.deltas.length-5)}render(){const t=this.deltas.reduce(((t,e)=>e+t),0)/this.deltas.length;this.el.innerHTML=`\n            <span class="timer">\n                ${this.name}:\n            </span>\n            <span class="strong">${t.toFixed(3)}</span> ms\n        `}}const x=new class{attach(t){const e=document.createElement("ul");t.appendChild(e),this.el=e,this.timers=[],setInterval((()=>this.render()),200)}createTimer(t){const e=document.createElement("li");this.el.appendChild(e);const i=new B(t,e);return this.timers.push(i),i}render(){this.timers.forEach((t=>t.render()))}};class C{constructor(t,e){this.toString=()=>`(${this.x}, ${this.y}, ${this.z})`,this.buffer=t,this.offset=e}get x(){return this.buffer[this.offset]}set x(t){this.buffer[this.offset]=t}get y(){return this.buffer[this.offset+1]}set y(t){this.buffer[this.offset+1]=t}get z(){return this.buffer[this.offset+2]}set z(t){this.buffer[this.offset+2]=t}}C.alignedLength=4;class _{constructor(t,e,i){this.id=t,this.vertices=e,this.offset=i}get position(){return new C(this.vertices.positions,this.offset*C.alignedLength)}set position(t){this.vertices.positions[this.offset*C.alignedLength]=t.x,this.vertices.positions[this.offset*C.alignedLength+1]=t.y,this.vertices.positions[this.offset*C.alignedLength+2]=t.z}get normal(){return new C(this.vertices.normals,this.offset*C.alignedLength)}set normal(t){this.vertices.normals[this.offset*C.alignedLength]=t.x,this.vertices.normals[this.offset*C.alignedLength+1]=t.y,this.vertices.normals[this.offset*C.alignedLength+2]=t.z}}class G{constructor(t){this.positions=new Float32Array(t*C.alignedLength),this.normals=new Int32Array(t*C.alignedLength),this.count=0,this.max=t}add(t){if(this.count+1>this.max)return new Error("max number of vertices reached");const e=new _(this.count,this,this.count);e.position=t.position,e.normal=t.normal,this.count++}get(t){return new _(t,this,t)}forEach(t){for(let e=0;e<this.count;e++)t(new _(e,this,e))}}class U{constructor(t,e,i){this.vertices=e,this.indexes=i,this.topology=function(t,e){const i=e.length/3,n=new Array(t.count),s={},o=[],r=[],a=(t,e)=>{n[t]||(n[t]=[]),n[t].push(e)};for(let t=0;t<i;t++){const i={a:e[3*t],b:e[3*t+1],c:e[3*t+2]};a(i.a,t),a(i.b,t),a(i.c,t);const n=[{start:Math.min(i.a,i.b),end:Math.max(i.a,i.b)},{start:Math.min(i.b,i.c),end:Math.max(i.b,i.c)},{start:Math.min(i.c,i.a),end:Math.max(i.c,i.a)}];o.push(i);for(let e of n){const i=`${e.start}-${e.end}`;s[i]?r[s[i]].triangles.push(t):(r.push({start:e.start,end:e.end,triangles:[t]}),s[i]=r.length-1)}}return{triangles:o,edges:r}}(e,i),this.device=t,this.indexBuffer=t.createBuffer({size:S(this.indexes.byteLength),usage:GPUBufferUsage.INDEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),this.positionBuffer=t.createBuffer({size:S(this.vertices.positions.byteLength),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),this.normalBuffer=t.createBuffer({size:S(this.vertices.normals.byteLength),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Uint32Array(this.indexBuffer.getMappedRange()).set(this.indexes),this.indexBuffer.unmap(),new Float32Array(this.positionBuffer.getMappedRange()).set(this.vertices.positions),this.positionBuffer.unmap(),new Float32Array(this.normalBuffer.getMappedRange()).set(this.vertices.normals),this.normalBuffer.unmap()}upload(){this.device.queue.writeBuffer(this.positionBuffer,0,this.vertices.positions,0,this.vertices.positions.length),this.device.queue.writeBuffer(this.normalBuffer,0,this.vertices.normals,0,this.vertices.normals.length)}}function M(e,i,n,s,o){const r=i/s,a=n/o;p.info(`plane geometry: size=(**${i}**, **${n}**) divisions=(**${s}**, **${o}**)`);const c=new G((o+1)*(s+1)),h=new Uint32Array(2*o*s*3);let l=0;for(let e=0;e<o+1;e++){const i=e*a;for(let e=0;e<s+1;e++){const n=e*r;c.add({position:t(n,0,i),normal:t(0,1,0)})}}for(let t=0;t<o;t++)for(let e=0;e<s;e++){const i=e+(s+1)*t,n=e+(s+1)*(t+1),o=e+1+(s+1)*(t+1),r=e+1+(s+1)*t;h.set([i,n,r],l),l+=3,h.set([n,o,r],l),l+=3}return new U(e,c,h)}function S(t){return t+3&-4}class L{constructor(e,i){this.device=i,this.config=Object.assign({deltaTime:1/60,subSteps:10,gravity:t(0,-9.8,0),relaxation:1},e),this.objects=[];const n=new Float32Array([this.config.gravity.x,this.config.gravity.y,this.config.gravity.z,this.config.deltaTime/this.config.subSteps]);var s;this.configBuffer=this.device.createBuffer({label:"config",size:(s=n.byteLength,s+3&-4),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});const o=i.createBindGroupLayout({label:"config",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});this.configBindGroup=this.device.createBindGroup({label:"config",layout:o,entries:[{binding:0,resource:{buffer:this.configBuffer}}]}),this.writeAllBuffer(this.configBuffer,n),this.colorBindGroupLayout=i.createBindGroupLayout({label:"current-color",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!0}}]});const r=i.createShaderModule({code:"struct SolverConfig {\n    gravity: vec3<f32>,\n    deltaTime: f32,\n};\n\nstruct ColorConfig {\n    start: u32,\n    count: u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> inverseMasses: array<f32>;\n@group(0) @binding(2) var<storage, read> restValues: array<f32>;\n@group(0) @binding(3) var<storage, read> compliances: array<f32>;\n@group(0) @binding(4) var<storage, read> affectedParticles: array<f32>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n@group(2) @binding(0) var<uniform> colorConfig: ColorConfig;\n\n@stage(compute) @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= u32(colorConfig.count)) {\n        return;\n    }\n\n    var constraint_id = colorConfig.start + id;\n    var p1_id = u32(affectedParticles[constraint_id * 2u]);\n    var p2_id = u32(affectedParticles[constraint_id * 2u + 1u]);\n\n    var w1 = inverseMasses[p1_id];\n    var w2 = inverseMasses[p2_id];\n\n    var sumWeight = w1 + w2;\n    if (sumWeight <= 0.0) {\n        return;\n    }\n\n    var alphaTilde = compliances[constraint_id] / (solverConfig.deltaTime * solverConfig.deltaTime);\n    var p1p2 = estimatedPositions[p1_id] - estimatedPositions[p2_id];\n\n    var distance = length(p1p2);\n\n    if (distance < 0.0000001) {\n        return;\n    }\n\n    var grad = p1p2 / distance;\n    var c = distance - restValues[constraint_id];\n    var lagrangeMultiplier = -c / (sumWeight + alphaTilde);\n\n    estimatedPositions[p1_id] += grad * lagrangeMultiplier * w1;\n    estimatedPositions[p2_id] += grad * -lagrangeMultiplier * w2;\n}\n"}),a=i.createShaderModule({code:"struct SolverConfig {\n    gravity: vec3<f32>,\n    deltaTime: f32,\n};\n\n@group(0) @binding(0) var<storage, read> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, write> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, read_write> velocities: array<vec3<f32>>;\n@group(0) @binding(3) var<storage, read> inverseMasses: array<f32>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n\n@stage(compute) @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= arrayLength(&positions)) {\n        return;\n    }\n\n    if (inverseMasses[id] > 0.0) {\n        velocities[id] += solverConfig.gravity * solverConfig.deltaTime;\n    }\n\n    estimatedPositions[id] = positions[id] + velocities[id] * solverConfig.deltaTime;\n}\n"}),c=i.createShaderModule({code:"struct SolverConfig {\n    gravity: vec3<f32>,\n    deltaTime: f32,\n};\n\n@group(0) @binding(0) var<storage, read_write> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, write> velocities: array<vec3<f32>>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n\n@stage(compute) @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= arrayLength(&positions)) {\n        return;\n    }\n\n    velocities[id] = (estimatedPositions[id] - positions[id]) / solverConfig.deltaTime;\n    positions[id] = estimatedPositions[id];\n}\n"}),h=i.createShaderModule({code:"@group(0) @binding(0) var<storage, read> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> indices: array<u32>;\n@group(0) @binding(2) var<storage, read_write> normals: array<atomic<i32>>;\n\n@stage(compute) @workgroup_size(16, 16)\nfn update_normal(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= arrayLength(&indices) / 3u) {\n        return;\n    }\n\n    let a = indices[id*3u];\n    let b = indices[id*3u + 1u];\n    let c = indices[id*3u + 2u];\n\n    let face_normal = vec3<i32>(cross(positions[b] - positions[a], positions[c] - positions[a]) * 10000.0);\n\n    atomicAdd(&normals[a*4u], face_normal.x);\n    atomicAdd(&normals[a*4u + 1u], face_normal.y);\n    atomicAdd(&normals[a*4u + 2u], face_normal.z);\n\n    atomicAdd(&normals[b*4u], face_normal.x);\n    atomicAdd(&normals[b*4u + 1u], face_normal.y);\n    atomicAdd(&normals[b*4u + 2u], face_normal.z);\n\n    atomicAdd(&normals[c*4u], face_normal.x);\n    atomicAdd(&normals[c*4u + 1u], face_normal.y);\n    atomicAdd(&normals[c*4u + 2u], face_normal.z);\n}\n"});this.semiExplicitEulerPipeline=i.createComputePipeline({label:"semi-explicit-euler",layout:i.createPipelineLayout({label:"semi-explicit-euler",bindGroupLayouts:[i.createBindGroupLayout({label:"semi-explicit-euler",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),o]}),compute:{module:a,entryPoint:"main"}}),this.applyConstraintPipeline=i.createComputePipeline({label:"apply-constraint",layout:i.createPipelineLayout({label:"apply-constraint",bindGroupLayouts:[i.createBindGroupLayout({label:"apply-constraint",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),o,this.colorBindGroupLayout]}),compute:{module:r,entryPoint:"main"}}),this.updatePositionPipeline=i.createComputePipeline({label:"update-position",layout:i.createPipelineLayout({label:"update-position",bindGroupLayouts:[i.createBindGroupLayout({label:"update-position",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),o]}),compute:{module:c,entryPoint:"main"}}),this.updateNormalPipeline=i.createComputePipeline({label:"update-normal",layout:i.createPipelineLayout({label:"update-normal",bindGroupLayouts:[i.createBindGroupLayout({label:"update-normal",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]})]}),compute:{module:h,entryPoint:"update_normal"}})}solve(t){return e=this,i=void 0,s=function*(){for(let e of this.objects){t.clearBuffer(e.cloth.geometry.normalBuffer);const i=t.beginComputePass();i.setBindGroup(1,this.configBindGroup);for(let t=0;t<this.config.subSteps;t++)this.semiExplicitEuler(i,e),this.applyConstraints(i,e),this.updatePositions(i,e);this.updateNormals(i,e),i.end()}},new((n=void 0)||(n=Promise))((function(t,o){function r(t){try{c(s.next(t))}catch(t){o(t)}}function a(t){try{c(s.throw(t))}catch(t){o(t)}}function c(e){var i;e.done?t(e.value):(i=e.value,i instanceof n?i:new n((function(t){t(i)}))).then(r,a)}c((s=s.apply(e,i||[])).next())}));var e,i,n,s}semiExplicitEuler(t,e){t.setPipeline(this.semiExplicitEulerPipeline),t.setBindGroup(0,e.eulerBindGroup);const i=Math.sqrt(e.cloth.particles.count),n=Math.ceil(i/16),s=Math.ceil(i/16);t.dispatchWorkgroups(n,s)}applyConstraints(t,e){t.setPipeline(this.applyConstraintPipeline),t.setBindGroup(0,e.constraintBindGroup),t.setBindGroup(1,this.configBindGroup);for(let i=0;i<e.cloth.constraints.colorCount;i++){t.setBindGroup(2,e.colorBindGroup,[256*i]);const n=Math.sqrt(e.cloth.constraints.colors[64*i+1]),s=Math.ceil(n/16),o=Math.ceil(n/16);t.dispatchWorkgroups(s,o)}}updatePositions(t,e){t.setPipeline(this.updatePositionPipeline),t.setBindGroup(0,e.positionBindGroup),t.setBindGroup(1,this.configBindGroup);const i=Math.sqrt(e.cloth.particles.count),n=Math.ceil(i/16),s=Math.ceil(i/16);t.dispatchWorkgroups(n,s)}updateNormals(t,e){t.setPipeline(this.updateNormalPipeline),t.setBindGroup(0,e.normalBindGroup);let i=Math.sqrt(e.cloth.geometry.indexes.length/3),n=Math.ceil(i/16),s=Math.ceil(i/16);t.dispatchWorkgroups(n,s)}add(t){t.particles.upload(),t.constraints.upload();const e=this.device.createBindGroup({layout:this.semiExplicitEulerPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.geometry.positionBuffer}},{binding:1,resource:{buffer:t.particles.estimatedPositionBuffer}},{binding:2,resource:{buffer:t.particles.velocityBuffer}},{binding:3,resource:{buffer:t.particles.inverseMassBuffer}}]}),i=this.device.createBindGroup({layout:this.applyConstraintPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.particles.estimatedPositionBuffer}},{binding:1,resource:{buffer:t.particles.inverseMassBuffer}},{binding:2,resource:{buffer:t.constraints.restValueBuffer}},{binding:3,resource:{buffer:t.constraints.complianceBuffer}},{binding:4,resource:{buffer:t.constraints.affectedParticleBuffer}}]}),n=this.device.createBindGroup({layout:this.updatePositionPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.geometry.positionBuffer}},{binding:1,resource:{buffer:t.particles.estimatedPositionBuffer}},{binding:2,resource:{buffer:t.particles.velocityBuffer}}]}),s=this.device.createBindGroup({layout:this.updateNormalPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.geometry.positionBuffer}},{binding:1,resource:{buffer:t.geometry.indexBuffer}},{binding:2,resource:{buffer:t.geometry.normalBuffer}}]}),o=this.device.createBindGroup({layout:this.colorBindGroupLayout,entries:[{binding:0,resource:{buffer:t.constraints.colorBuffer,size:8,offset:0}}]});this.objects.push({cloth:t,eulerBindGroup:e,constraintBindGroup:i,positionBindGroup:n,normalBindGroup:s,colorBindGroup:o})}writeAllBuffer(t,e){this.device.queue.writeBuffer(t,0,e,0,e.length)}}class z{constructor(e,i){this.canvas=e,this.device=i,this.paused=!0,this.stopped=!1,this.camera=new w(e,i,{width:e.width,height:e.height}),this.renderer=new P(e,i),this.solver=new L({deltaTime:1/60,subSteps:15,relaxation:1,gravity:t(0,-9.8,0)},this.device);const n=M(this.device,10,10,30,30);this.cloth=new m(this.device,n,{stretchCompliance:0,bendCompliance:.3},t(-5,0,0)),this.solver.add(this.cloth)}run(){return t=this,e=void 0,n=function*(){this.stopped=!1;const t=x.createTimer("tick");do{t.end(),yield new Promise(window.requestAnimationFrame),t.start();const e=this.device.createCommandEncoder();this.paused||(yield this.solver.solve(e));const i=this.cloth.getRenderPipeline(this.camera);i&&this.renderer.render(e,this.cloth.geometry,i,[this.camera.uniformBindGroup,this.cloth.uniformBindGroup]),this.device.queue.submit([e.finish()]),yield this.device.queue.onSubmittedWorkDone()}while(!this.stopped)},new((i=void 0)||(i=Promise))((function(s,o){function r(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?s(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,a)}c((n=n.apply(t,e||[])).next())}));var t,e,i,n}stop(){this.stopped=!0}}class E{constructor(t,e){this.app=t,this.device=e,this.renderNeeded=!0,this.config={paused:!0,solver:{deltaTime:1/60,subSteps:10,relaxation:1},cloth:{unit:.01,density:.27,width:10,height:10,widthDivisions:10,heightDivisions:10,stretchCompliance:0,bendCompliance:.3}}}attach(t){this.el=t,this.updateApp(this.config,!0),setInterval((()=>this.run()),50),window.addEventListener("keypress",(t=>{"Space"===t.code&&this.togglePlay()}))}run(){if(!this.renderNeeded)return;this.el.innerHTML=this.render(),this.renderNeeded=!1;const t=document.getElementById("play"),e=document.getElementById("restart"),i=document.getElementById("apply");t.addEventListener("click",(t=>{t.preventDefault(),this.togglePlay()})),e.addEventListener("click",(t=>{t.preventDefault(),this.restartSimulation()})),i.addEventListener("click",(t=>{t.preventDefault(),this.apply()}))}render(){return`\n            <form>\n                <div>\n                    <div class="column">\n                        <label for="cloth-unit">\n                            <span>unit</span>\n                            <input type="number" id="cloth-unit" name="cloth-unit"\n                                value=${this.config.cloth.unit}\n                                step=0.001\n                                min=0.000001\n                                max=1000 />\n                        </label>\n                        <label for="cloth-density">\n                            <span>density</span>\n                            <input type="number" id="cloth-density" name="cloth-density"\n                                value=${this.config.cloth.density}\n                                step=0.001\n                                min=0.000001\n                                max=1000 />\n                        </label>\n                        <label for="cloth-width">\n                            <span>width</span>\n                            <input type="number" id="cloth-width" name="cloth-width"\n                                value=${this.config.cloth.width}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-height">\n                            <span>height</span>\n                            <input type="number" id="cloth-height" name="cloth-height"\n                                value=${this.config.cloth.height}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-width-divisions">\n                            <span>width-division</span>\n                            <input type="number" id="cloth-width-divisions" name="cloth-width-divisions"\n                                value=${this.config.cloth.widthDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-height-divisions">\n                            <span>height-division</span>\n                            <input type="number" id="cloth-height-divisions" name="cloth-height-divisions"\n                                value=${this.config.cloth.heightDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-stretch-compliance">\n                            <span>stretch compliance</span>\n                            <input type="number" id="cloth-stretch-compliance" name="cloth-stretch-compliance"\n                                value=${this.config.cloth.stretchCompliance}\n                                step=0.1\n                                min=0\n                                max=1 />\n                        </label>\n\n                        <label for="cloth-bend-compliance">\n                            <span>bend compliance</span>\n                            <input type="number" id="cloth-bend-compliance" name="cloth-bend-compliance"\n                                value=${this.config.cloth.bendCompliance}\n                                step=0.1\n                                min=0\n                                max=1 />\n                        </label>\n                    </div>\n\n                    <div class="column">\n                        <label for="solver-sub-steps">\n                            <span>sub-steps</span>\n                            <input type="number" id="solver-sub-steps" name="solver-sub-steps"\n                                value=${this.config.solver.subSteps}\n                                step=1\n                                min=1\n                                max=500 />\n                        </label>\n                    </div>\n                </div>\n\n                <div class="row">\n                    <button id="play">${this.config.paused?"Play":"Pause"}</button>\n                    <button id="restart">Restart</button>\n                    <button id="apply">Apply</button>\n                </div>\n            </form>\n        `}updateApp(t,e=!1){const i=t.cloth.width!==this.config.cloth.width||t.cloth.height!==this.config.cloth.height||t.cloth.widthDivisions!==this.config.cloth.widthDivisions||t.cloth.heightDivisions!==this.config.cloth.heightDivisions,n=t.cloth.stretchCompliance!==this.config.cloth.stretchCompliance||t.cloth.bendCompliance!==this.config.cloth.bendCompliance||t.cloth.unit!==this.config.cloth.unit||t.cloth.density!==this.config.cloth.density,s=t.solver.subSteps!==this.config.solver.subSteps;(e||i)&&(p.info("resetting the simulation with a new cloth geometry"),this.app.cloth.geometry=M(this.device,t.cloth.width,t.cloth.height,t.cloth.widthDivisions,t.cloth.heightDivisions)),(e||n)&&(this.app.cloth.config={unit:t.cloth.unit,density:t.cloth.density,stretchCompliance:t.cloth.stretchCompliance,bendCompliance:t.cloth.bendCompliance}),(e||s||i||n)&&(this.app.solver=new L(t.solver,this.device),this.app.solver.add(this.app.cloth))}buildConfiguration(){const t=new FormData(this.el.querySelector("form")),e=Object.assign(Object.assign({},this.config),{cloth:{unit:parseFloat(t.get("cloth-unit")),density:parseFloat(t.get("cloth-density")),width:parseFloat(t.get("cloth-width")),height:parseFloat(t.get("cloth-height")),widthDivisions:parseInt(t.get("cloth-width-divisions")),heightDivisions:parseInt(t.get("cloth-height-divisions")),stretchCompliance:parseFloat(t.get("cloth-stretch-compliance")),bendCompliance:parseFloat(t.get("cloth-bend-compliance"))},solver:Object.assign(Object.assign({},this.config.solver),{subSteps:parseInt(t.get("solver-sub-steps"))})});return this.renderNeeded=!0,e}apply(){const t=this.buildConfiguration();this.updateApp(t),this.config=t}restartSimulation(){this.app.cloth.geometry=M(this.device,this.config.cloth.width,this.config.cloth.height,this.config.cloth.widthDivisions,this.config.cloth.heightDivisions)}togglePlay(){this.config.paused=!this.config.paused,this.app.paused=this.config.paused,this.renderNeeded=!0}}(function(){return t=this,e=void 0,n=function*(){const t=navigator.gpu;if(!t)throw new Error("WebGPU is not supported on this browser.");const e=yield t.requestAdapter();let i="";for(let t in e.limits)i+=` - ${t}: **${e.limits[t]}**\n`;p.info(`limits:\n ${i}`);const n=yield e.requestDevice(),s=document.getElementById("app");s.width=1e3,s.height=512;const o=new z(s,n),r=new E(o,n);return p.attach(document.getElementById("logger")),x.attach(document.getElementById("monitor")),r.attach(document.getElementById("controller")),o.run()},new((i=void 0)||(i=Promise))((function(s,o){function r(t){try{c(n.next(t))}catch(t){o(t)}}function a(t){try{c(n.throw(t))}catch(t){o(t)}}function c(t){var e;t.done?s(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,a)}c((n=n.apply(t,e||[])).next())}));var t,e,i,n})().then((()=>p.info("done"))).catch((t=>console.error(t.toString()+"\n"+t.stack)))}();