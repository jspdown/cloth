!function(){"use strict";function e(e,t,i){return{x:e,y:t,z:i}}function t(e,t){return{x:e.x-t.x,y:e.y-t.y,z:e.z-t.z}}var i={randomUUID:"undefined"!=typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let s;const n=new Uint8Array(16);function o(){if(!s&&(s="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!s))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return s(n)}const a=[];for(let e=0;e<256;++e)a.push((e+256).toString(16).slice(1));var r=function(e,t,s){if(i.randomUUID&&!t&&!e)return i.randomUUID();const n=(e=e||{}).random||(e.rng||o)();if(n[6]=15&n[6]|64,n[8]=63&n[8]|128,t){s=s||0;for(let e=0;e<16;++e)t[s+e]=n[e];return t}return function(e,t=0){return(a[e[t+0]]+a[e[t+1]]+a[e[t+2]]+a[e[t+3]]+"-"+a[e[t+4]]+a[e[t+5]]+"-"+a[e[t+6]]+a[e[t+7]]+"-"+a[e[t+8]]+a[e[t+9]]+"-"+a[e[t+10]]+a[e[t+11]]+a[e[t+12]]+a[e[t+13]]+a[e[t+14]]+a[e[t+15]]).toLowerCase()}(n)};class c{constructor(e,t){this.buffer=e,this.offset=t}get x(){return this.buffer[this.offset]}set x(e){this.buffer[this.offset]=e}get y(){return this.buffer[this.offset+1]}set y(e){this.buffer[this.offset+1]=e}get z(){return this.buffer[this.offset+2]}set z(e){this.buffer[this.offset+2]=e}toString(){return`(${this.x}, ${this.y}, ${this.z})`}}c.alignedLength=4;class d{constructor(e,t,i){this.id=e,this.data=t,this.offset=i}get position(){return new c(this.data.positions,this.offset*c.alignedLength)}set position(e){this.data.positions[this.offset*c.alignedLength]=e.x,this.data.positions[this.offset*c.alignedLength+1]=e.y,this.data.positions[this.offset*c.alignedLength+2]=e.z,this.data.uploadNeeded=!0}get estimatedPosition(){return new c(this.data.estimatedPositions,this.offset*c.alignedLength)}set estimatedPosition(e){this.data.estimatedPositions[this.offset*c.alignedLength]=e.x,this.data.estimatedPositions[this.offset*c.alignedLength+1]=e.y,this.data.estimatedPositions[this.offset*c.alignedLength+2]=e.z,this.data.uploadNeeded=!0}get velocity(){return new c(this.data.velocities,this.offset*c.alignedLength)}set velocity(e){this.data.velocities[this.offset*c.alignedLength]=e.x,this.data.velocities[this.offset*c.alignedLength+1]=e.y,this.data.velocities[this.offset*c.alignedLength+2]=e.z,this.data.uploadNeeded=!0}get inverseMass(){return this.data.inverseMasses[this.offset]}set inverseMass(e){this.data.inverseMasses[this.offset]=e,this.data.uploadNeeded=!0}}class l{constructor(e,t){this.device=e,this.data={uploadNeeded:!0,positions:new Float32Array(t*c.alignedLength),velocities:new Float32Array(t*c.alignedLength),estimatedPositions:new Float32Array(t*c.alignedLength),inverseMasses:new Float32Array(t)},this.estimatedPositionBuffer=this.device.createBuffer({label:"estimated-position",size:h(this.data.estimatedPositions.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.velocityBuffer=this.device.createBuffer({label:"velocity",size:h(this.data.velocities.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),this.inverseMassBuffer=this.device.createBuffer({label:"inverse-masses",size:h(this.data.inverseMasses.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.count=0,this.max=t}get uploadNeeded(){return this.data.uploadNeeded}upload(){this.device.queue.writeBuffer(this.estimatedPositionBuffer,0,this.data.estimatedPositions,0,this.count),this.device.queue.writeBuffer(this.velocityBuffer,0,this.data.velocities,0,this.count),this.device.queue.writeBuffer(this.inverseMassBuffer,0,this.data.inverseMasses,0,this.count),this.data.uploadNeeded=!1}add(e){if(this.count>=this.max)throw new Error("max number of particles reached");const t=new d(this.count,this.data,this.count);t.position=e.position,t.estimatedPosition=e.estimatedPosition,t.velocity=e.velocity,t.inverseMass=e.inverseMass,this.count++}get(e){return new d(e,this.data,e)}forEach(e){for(let t=0;t<this.count;t++)e(new d(t,this.data,t))}}function h(e){return e+3&-4}class u{constructor(e,t){this.data=e,this.offset=t}get p1(){return this.data.affectedParticles[2*this.offset]}set p1(e){this.data.affectedParticles[2*this.offset]=e,this.data.uploadNeeded=!0}get p2(){return this.data.affectedParticles[2*this.offset+1]}set p2(e){this.data.affectedParticles[2*this.offset+1]=e,this.data.uploadNeeded=!0}get restValue(){return this.data.restValues[this.offset]}set restValue(e){this.data.restValues[this.offset]=e,this.data.uploadNeeded=!0}get compliance(){return this.data.compliances[this.offset]}set compliance(e){this.data.compliances[this.offset]=e,this.data.uploadNeeded=!0}unref(){return{p1:this.p1,p2:this.p2,restValue:this.restValue,compliance:this.compliance}}}class f{constructor(e,t){this.device=e,this.data={uploadNeeded:!0,restValues:new Float32Array(t),compliances:new Float32Array(t),affectedParticles:new Float32Array(2*t)},this.colors=new Uint32Array(3200),this.adjacency=[],this.count=0,this.colorCount=0,this.max=t,this.restValueBuffer=this.device.createBuffer({label:"rest-values",size:p(this.data.restValues.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.complianceBuffer=this.device.createBuffer({label:"compliances",size:p(this.data.compliances.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.affectedParticleBuffer=this.device.createBuffer({label:"affected-particles",size:p(this.data.affectedParticles.byteLength),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.colorBuffer=this.device.createBuffer({label:"colors",size:p(this.colors.byteLength),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})}get uploadNeeded(){return this.data.uploadNeeded}upload(){this.color(),this.device.queue.writeBuffer(this.restValueBuffer,0,this.data.restValues,0,this.count),this.device.queue.writeBuffer(this.complianceBuffer,0,this.data.compliances,0,this.count),this.device.queue.writeBuffer(this.affectedParticleBuffer,0,this.data.affectedParticles,0,2*this.count),this.device.queue.writeBuffer(this.colorBuffer,0,this.colors,0,64*this.colorCount),this.data.uploadNeeded=!1}add(e,t,i){if(this.count>=this.max)throw new Error("max number of constraints reached");const s=new u(this.data,this.count);s.compliance=i,s.restValue=function(e,t){const i=e.x,s=e.y,n=e.z,o=t.x,a=t.y,r=t.z;return Math.sqrt((i-o)*(i-o)+(s-a)*(s-a)+(n-r)*(n-r))}(e.position,t.position),s.p1=e.id,s.p2=t.id,this.addAdjacency(e.id,t.id),this.addAdjacency(t.id,e.id),this.count++}get(e){return new u(this.data,e)}set(e,t){if(e<0||e>=this.count)throw new Error("out of bound");const i=new u(this.data,e);i.compliance=t.compliance,i.restValue=t.restValue,i.p1=t.p1,i.p2=t.p2}forEach(e){for(let t=0;t<this.count;t++)e(new u(this.data,t))}addAdjacency(e,t){if(e>this.adjacency.length-1)for(let t=this.adjacency.length;t<=e;t++)this.adjacency.push([]);this.adjacency[e].push(t)}color(){this.colorCount=0;const e=[],t=new Array(this.count).fill(!1),i=new Array(this.adjacency.length).fill(!1);let s=this.count;for(;s;){if(this.colorCount>=50)throw new Error("max number of colors reached");i.fill(!1);const n=e.length;for(let n=0;n<this.count;n++){if(t[n])continue;const o=this.data.affectedParticles[2*n],a=this.data.affectedParticles[2*n+1];i[o]||i[a]||(e.push(n),t[n]=!0,i[o]=!0,i[a]=!0,s--)}this.colors[64*this.colorCount]=n,this.colors[64*this.colorCount+1]=e.length-n,this.colorCount++}for(let t=0;t<this.count;t++){if(e[t]===t)continue;const i=this.get(t).unref();let s=t,n=e[s];for(;t!==n;)this.set(s,this.get(n)),e[s]=s,s=n,n=e[s];this.set(s,i),e[s]=s}}}function p(e){return e+3&-4}class g{constructor(e,t,i){this.id=r(),this.config=i,this.device=e,this.geometry=t,this.wireframe=!1,this.initParticles(),this.initConstraints()}get uploadNeeded(){return this.geometry.vertices.uploadNeeded||this.geometry.triangles.uploadNeeded||this.particles.uploadNeeded||this.constraints.uploadNeeded}upload(){this.geometry.vertices.uploadNeeded&&this.geometry.vertices.upload(),this.geometry.triangles.uploadNeeded&&this.geometry.triangles.upload(),this.particles.uploadNeeded&&this.particles.upload(),this.constraints.uploadNeeded&&this.constraints.upload()}initParticles(){this.particles=new l(this.device,this.geometry.vertices.count),this.geometry.vertices.forEach((e=>this.particles.add({position:e.position,velocity:{x:0,y:0,z:0},estimatedPosition:{x:0,y:0,z:0},inverseMass:0}))),this.geometry.triangles.forEach((e=>{const i=this.particles.get(e.a),s=this.particles.get(e.b),n=this.particles.get(e.c),o=.5*(r=function(e,t){const i=e.x,s=e.y,n=e.z,o=t.x,a=t.y,r=t.z;return e.x=s*r-n*a,e.y=n*o-i*r,e.z=i*a-s*o,e}(t(s.position,i.position),t(n.position,i.position)),Math.sqrt(function(e){const t=e.x,i=e.y,s=e.z;return t*t+i*i+s*s}(r))),a=1/(this.config.unit*o*this.config.density)/3;var r;i.inverseMass+=a,s.inverseMass+=a,n.inverseMass+=a})),this.particles.forEach((e=>{0===e.position.z&&(e.inverseMass=0)}))}initConstraints(){const e=this.geometry.triangles.extractTopology(),t=e.edges.length+e.adjacentTriangles.length;this.constraints=new f(this.device,t),e.edges.forEach((([e,t])=>{this.constraints.add(this.particles.get(e),this.particles.get(t),this.config.stretchCompliance)})),e.adjacentTriangles.forEach((([e,t])=>{const i=this.geometry.triangles.get(e).toArray(),s=this.geometry.triangles.get(t).toArray(),[n]=i.filter((e=>!s.includes(e))),[o]=s.filter((e=>!i.includes(e)));this.constraints.add(this.particles.get(n),this.particles.get(o),this.config.bendCompliance)}))}}function m(e){return e*(Math.PI/180)}class v{constructor(e,t,i){this.device=e,this.config=Object.assign({fovy:Math.PI/4,near:1e-4,far:1e3,zoomSpeed:2,distance:5,rotationX:90,rotationY:0},i),this.zoom=0,this.dragging=!1,this.rotateX=this.config.rotationX,this.rotateY=this.config.rotationY,this.x=0,this.y=0,this.lastX=0,this.lastY=0,this.limitX=85,this.buffer=e.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),t.addEventListener("mousedown",(()=>this.onMouseButtonPressed())),t.addEventListener("mouseup",(()=>this.onMouseButtonReleased())),t.addEventListener("wheel",(e=>this.onMouseWheel(e.deltaY)),{passive:!0}),t.addEventListener("mousemove",(e=>this.onMouseMove(e.clientX,e.clientY))),this.updateUniform()}onMouseButtonPressed(){this.dragging=!0,this.lastX=this.x,this.lastY=this.y}onMouseButtonReleased(){this.dragging=!1}onMouseMove(e,t){this.x=e,this.y=t,this.dragging&&this.drag(this.x,this.y)}onMouseWheel(e){this.zoom+=e<0?-1:1,this.updateUniform()}drag(e,t){let i=90/this.config.height,s=180/this.config.width,n=this.rotateX+i*(t-this.lastY),o=this.rotateY+s*(e-this.lastX);(n<-this.limitX||n>this.limitX)&&(n=this.limitX),this.lastX=e,this.lastY=t,(Math.abs(n-this.rotateX)>.01||Math.abs(o-this.rotateY)>.01)&&(this.rotateX=n,this.rotateY=o),this.updateUniform()}updateUniform(){const t=function(e,t,i,s){const n=1/Math.tan(e/2),o=1/(t-i),a=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return a[0]=n/s,a[5]=n,a[10]=(i+t)*o,a[11]=-1,a[14]=2*i*t*o,a}(this.config.fovy,this.config.near,this.config.far,this.config.width/this.config.height),i=e(0,0,-Math.pow(.95,-this.zoom)*this.config.zoomSpeed*this.config.distance),s=e(m(this.rotateX),m(this.rotateY),0),n=function(e,t){const i=e[0],s=e[1],n=e[2],o=e[3],a=e[4],r=e[5],c=e[6],d=e[7],l=e[8],h=e[9],u=e[10],f=e[11],p=e[12],g=e[13],m=e[14],v=e[15];let b=t[0],y=t[1],w=t[2],P=t[3];return e[0]=b*i+y*a+w*l+P*p,e[1]=b*s+y*r+w*h+P*g,e[2]=b*n+y*c+w*u+P*m,e[3]=b*o+y*d+w*f+P*v,b=t[4],y=t[5],w=t[6],P=t[7],e[4]=b*i+y*a+w*l+P*p,e[5]=b*s+y*r+w*h+P*g,e[6]=b*n+y*c+w*u+P*m,e[7]=b*o+y*d+w*f+P*v,b=t[8],y=t[9],w=t[10],P=t[11],e[8]=b*i+y*a+w*l+P*p,e[9]=b*s+y*r+w*h+P*g,e[10]=b*n+y*c+w*u+P*m,e[11]=b*o+y*d+w*f+P*v,b=t[12],y=t[13],w=t[14],P=t[15],e[12]=b*i+y*a+w*l+P*p,e[13]=b*s+y*r+w*h+P*g,e[14]=b*n+y*c+w*u+P*m,e[15]=b*o+y*d+w*f+P*v,e}(function(e){const t=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return t[12]=e.x,t[13]=e.y,t[14]=e.z,t}(i),function(e,t){const i=Math.sin(t),s=Math.cos(t),n=e[0],o=e[1],a=e[2],r=e[3],c=e[4],d=e[5],l=e[6],h=e[7];return e[0]=n*s+c*i,e[1]=o*s+d*i,e[2]=a*s+l*i,e[3]=r*s+h*i,e[4]=c*s-n*i,e[5]=d*s-o*i,e[6]=l*s-a*i,e[7]=h*s-r*i,e}(function(e,t){const i=Math.sin(t),s=Math.cos(t),n=e[0],o=e[1],a=e[2],r=e[3],c=e[8],d=e[9],l=e[10],h=e[11];return e[0]=n*s-c*i,e[1]=o*s-d*i,e[2]=a*s-l*i,e[3]=r*s-h*i,e[8]=n*i+c*s,e[9]=o*i+d*s,e[10]=a*i+l*s,e[11]=r*i+h*s,e}(function(e,t){const i=Math.sin(t),s=Math.cos(t),n=e[4],o=e[5],a=e[6],r=e[7],c=e[8],d=e[9],l=e[10],h=e[11];return e[4]=n*s+c*i,e[5]=o*s+d*i,e[6]=a*s+l*i,e[7]=r*s+h*i,e[8]=c*s-n*i,e[9]=d*s-o*i,e[10]=l*s-a*i,e[11]=h*s-r*i,e}([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],(a=s).x),a.y),a.z)),o=new Float32Array(32);var a;o.set(t,0),o.set(n,16),this.device.queue.writeBuffer(this.buffer,0,o,0,o.length)}}const b={entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]};class y{constructor(e,t){this.device=e,this.objectStates={},this.context=t.getContext("webgpu"),this.context.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:"opaque"});const i={label:"depth texture",size:[t.width,t.height,1],dimension:"2d",format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},s=this.device.createTexture(i);this.depthTextureView=s.createView()}render(e,t,i){let s=this.objectStates[t.id];s&&s.wireframe===t.wireframe||(s=new w(this.device,t,i),this.objectStates[t.id]=s);const n={colorAttachments:[{view:this.context.getCurrentTexture().createView({label:"color texture"}),loadOp:"clear",clearValue:{r:.83,g:.85,b:.86,a:1},storeOp:"store"}],depthStencilAttachment:{view:this.depthTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},o=e.beginRenderPass(n),{width:a,height:r}=this.context.canvas;o.setPipeline(s.pipeline),o.setViewport(0,0,a,r,0,1),o.setScissorRect(0,0,a,r),o.setVertexBuffer(0,t.geometry.vertices.positionBuffer),o.setVertexBuffer(1,t.geometry.vertices.normalBuffer),o.setIndexBuffer(s.indexBuffer,"uint32"),o.setBindGroup(0,s.cameraBindGroup),o.drawIndexed(s.indexCount),o.end()}}class w{constructor(e,t,i){const s=e.createShaderModule({code:"struct Output {\n    @builtin(position) Position: vec4<f32>,\n    @location(0) Normal: vec3<f32>,\n};\n\nstruct Camera {\n    projection: mat4x4<f32>,\n    view: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> camera: Camera;\n\n@vertex\nfn main(@location(0) position: vec3<f32>, @location(1) normal: vec3<i32>) -> Output {\n    var output: Output;\n\n    output.Normal = normalize(vec3<f32>(normal) / 10000.0);\n    output.Position = camera.projection * camera.view * vec4<f32>(position, 1.0);\n\n    return output;\n}\n"}),n=e.createShaderModule({code:"@fragment\nfn main(@location(0) normal: vec3<f32>) -> @location(0) vec4<f32> {\n    return vec4<f32>(normal, 1.0);\n}\n"});this.wireframe=t.wireframe,this.indexBuffer=t.geometry.triangles.indexBuffer,this.indexCount=3*t.geometry.triangles.count,this.cameraBindGroup=e.createBindGroup({layout:e.createBindGroupLayout(b),entries:[{binding:0,resource:{buffer:i.buffer}}]});let o="triangle-list";if(this.wireframe){o="line-list";const i=function(e){const t=e.extractTopology(),i=new Uint32Array(2*t.edges.length);let s=0;return t.edges.forEach((e=>{i[s]=e[0],i[s+1]=e[1],s+=2})),i}(t.geometry.triangles);this.indexCount=i.length,this.indexBuffer=e.createBuffer({label:"index",size:(a=i.byteLength,a+3&-4),usage:GPUBufferUsage.INDEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.indexBuffer,0,i,0,i.length)}var a;this.pipeline=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[e.createBindGroupLayout(b)]}),vertex:{module:s,entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"}],arrayStride:16,stepMode:"vertex"},{attributes:[{shaderLocation:1,offset:0,format:"sint32x3"}],arrayStride:16,stepMode:"vertex"}]},fragment:{module:n,entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{frontFace:"cw",cullMode:"none",topology:o},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}})}}class P{constructor(e,t){this.name=e,this.deltas=[],this.el=t}start(){this._start=window.performance.now()}end(){const e=window.performance.now()-this._start;this.deltas.push(e),this.deltas.length>5&&this.deltas.splice(0,this.deltas.length-5)}render(){const e=this.deltas.reduce(((e,t)=>t+e),0)/this.deltas.length;this.el.innerHTML=`\n            <span class="timer">\n                ${this.name}:\n            </span>\n            <span class="strong">${e.toFixed(3)}</span> ms\n        `}}const B=new class{attach(e){const t=document.createElement("ul");e.appendChild(t),this.el=t,this.timers=[],setInterval((()=>this.render()),200)}createTimer(e){const t=document.createElement("li");this.el.appendChild(t);const i=new P(e,t);return this.timers.push(i),i}render(){this.timers.forEach((e=>e.render()))}};class U{constructor(e,t){this.buffer=e,this.offset=t}get x(){return this.buffer[this.offset]}set x(e){this.buffer[this.offset]=e}get y(){return this.buffer[this.offset+1]}set y(e){this.buffer[this.offset+1]=e}get z(){return this.buffer[this.offset+2]}set z(e){this.buffer[this.offset+2]=e}toString(){return`(${this.x}, ${this.y}, ${this.z})`}}U.alignedLength=4;class x{constructor(e,t,i){this.id=e,this.data=t,this.offset=i}get position(){return new U(this.data.positions,this.offset*U.alignedLength)}set position(e){this.data.positions[this.offset*U.alignedLength]=e.x,this.data.positions[this.offset*U.alignedLength+1]=e.y,this.data.positions[this.offset*U.alignedLength+2]=e.z,this.data.uploadNeeded=!0}get normal(){return new U(this.data.normals,this.offset*U.alignedLength)}set normal(e){this.data.normals[this.offset*U.alignedLength]=e.x,this.data.normals[this.offset*U.alignedLength+1]=e.y,this.data.normals[this.offset*U.alignedLength+2]=e.z,this.data.uploadNeeded=!0}}class C{constructor(e,t){this.device=e,this.data={uploadNeeded:!0,positions:new Float32Array(t*U.alignedLength),normals:new Int32Array(t*U.alignedLength)},this.positionBuffer=e.createBuffer({size:G(this.data.positions.byteLength),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.normalBuffer=e.createBuffer({size:G(this.data.normals.byteLength),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.count=0,this.max=t}get uploadNeeded(){return this.data.uploadNeeded}upload(){this.device.queue.writeBuffer(this.positionBuffer,0,this.data.positions,0,this.data.positions.length),this.device.queue.writeBuffer(this.normalBuffer,0,this.data.normals,0,this.data.normals.length),this.data.uploadNeeded=!1}add(e){if(this.count>=this.max)return new Error("max number of vertices reached");const t=new x(this.count,this.data,this.count);t.position=e.position,t.normal=e.normal,this.count++}get(e){return new x(e,this.data,e)}forEach(e){for(let t=0;t<this.count;t++)e(new x(t,this.data,t))}}function G(e){return e+3&-4}class S{constructor(e,t,i){this.id=e,this.data=t,this.offset=i}get a(){return this.data.indices[3*this.offset]}set a(e){this.data.indices[3*this.offset]=e,this.data.uploadNeeded=!0}get b(){return this.data.indices[3*this.offset+1]}set b(e){this.data.indices[3*this.offset+1]=e,this.data.uploadNeeded=!0}get c(){return this.data.indices[3*this.offset+2]}set c(e){this.data.indices[3*this.offset+2]=e,this.data.uploadNeeded=!0}toArray(){return[this.a,this.b,this.c]}toString(){return`(${this.a}, ${this.b}, ${this.c})`}}class M{constructor(e,t){var i;this.device=e,this.max=t,this.count=0,this.data={uploadNeeded:!0,indices:new Uint32Array(3*t)},this.indexBuffer=this.device.createBuffer({label:"index",size:(i=this.data.indices.byteLength,i+3&-4),usage:GPUBufferUsage.INDEX|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST})}get uploadNeeded(){return this.data.uploadNeeded}upload(){this.device.queue.writeBuffer(this.indexBuffer,0,this.data.indices,0,this.data.indices.length),this.data.uploadNeeded=!1}add(e,t,i){if(this.count>=this.max)throw new Error("max number of particles reached");const s=new S(this.count,this.data,this.count);s.a=e,s.b=t,s.c=i,this.count++}get(e){return new S(e,this.data,e)}forEach(e){for(let t=0;t<this.count;t++)e(new S(t,this.data,t))}extractTopology(){const e=[];this.forEach((t=>{const[i,s,n]=[t.a,t.b,t.c].sort();e.push([i,s,t.id],[i,n,t.id],[s,n,t.id])})),e.sort(((e,t)=>e[0]===t[0]?e[1]-t[1]:t[0]-e[0]));const t=[],i=[];let s=[-1,-1];for(let n=0;n<e.length;n++){const[o,a,r]=e[n],[c,d,l]=s;o==c&&a==d?i.push([l,r]):t.push([o,a]),s=e[n]}return{edges:t,adjacentTriangles:i}}}function E(t,i,s,n,o){const a=i/n,r=s/o,c=new C(t,(o+1)*(n+1)),d=new M(t,2*o*n);for(let t=0;t<o+1;t++){const i=t*r;for(let t=0;t<n+1;t++){const s=t*a;c.add({position:e(s,0,i),normal:e(0,1,0)})}}for(let e=0;e<o;e++)for(let t=0;t<n;t++){const i=t+(n+1)*e,s=t+(n+1)*(e+1),o=t+1+(n+1)*(e+1),a=t+1+(n+1)*e;d.add(i,s,a),d.add(s,o,a)}return{vertices:c,triangles:d}}const _={label:"semi-explicit-euler",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]},L={label:"apply-constraint",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]},T={label:"update-position",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]},z={label:"update-normal",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]},O={label:"current-color",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform",hasDynamicOffset:!0}}]},N={label:"config",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]};class A{constructor(t,i){this.device=t,this.objectStates={},this.config=Object.assign({deltaTime:1/60,subSteps:10,gravity:e(0,-9.8,0),relaxation:1},i);const s=new Float32Array([this.config.gravity.x,this.config.gravity.y,this.config.gravity.z,this.config.deltaTime/this.config.subSteps]);var n;this.configBuffer=this.device.createBuffer({label:"config",size:(n=s.byteLength,n+3&-4),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.configBindGroup=this.device.createBindGroup({label:"config",layout:t.createBindGroupLayout(N),entries:[{binding:0,resource:{buffer:this.configBuffer}}]}),this.device.queue.writeBuffer(this.configBuffer,0,s,0,s.length);const o=t.createShaderModule({code:"struct SolverConfig {\n    gravity: vec3<f32>,\n    deltaTime: f32,\n};\n\nstruct ColorConfig {\n    start: u32,\n    count: u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> inverseMasses: array<f32>;\n@group(0) @binding(2) var<storage, read> restValues: array<f32>;\n@group(0) @binding(3) var<storage, read> compliances: array<f32>;\n@group(0) @binding(4) var<storage, read> affectedParticles: array<f32>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n@group(2) @binding(0) var<uniform> colorConfig: ColorConfig;\n\n@compute @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= u32(colorConfig.count)) {\n        return;\n    }\n\n    var constraint_id = colorConfig.start + id;\n    var p1_id = u32(affectedParticles[constraint_id * 2u]);\n    var p2_id = u32(affectedParticles[constraint_id * 2u + 1u]);\n\n    var w1 = inverseMasses[p1_id];\n    var w2 = inverseMasses[p2_id];\n\n    var sumWeight = w1 + w2;\n    if (sumWeight <= 0.0) {\n        return;\n    }\n\n    var alphaTilde = compliances[constraint_id] / (solverConfig.deltaTime * solverConfig.deltaTime);\n    var p1p2 = estimatedPositions[p1_id] - estimatedPositions[p2_id];\n\n    var distance = length(p1p2);\n\n    if (distance < 0.0000001) {\n        return;\n    }\n\n    var grad = p1p2 / distance;\n    var c = distance - restValues[constraint_id];\n    var lagrangeMultiplier = -c / (sumWeight + alphaTilde);\n\n    estimatedPositions[p1_id] += grad * lagrangeMultiplier * w1;\n    estimatedPositions[p2_id] += grad * -lagrangeMultiplier * w2;\n}\n"}),a=t.createShaderModule({code:"struct SolverConfig {\n    gravity: vec3<f32>,\n    deltaTime: f32,\n};\n\n@group(0) @binding(0) var<storage, read> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read_write> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, read_write> velocities: array<vec3<f32>>;\n@group(0) @binding(3) var<storage, read> inverseMasses: array<f32>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n\n@compute @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= arrayLength(&positions)) {\n        return;\n    }\n\n    if (inverseMasses[id] > 0.0) {\n        velocities[id] += solverConfig.gravity * solverConfig.deltaTime;\n    }\n\n    estimatedPositions[id] = positions[id] + velocities[id] * solverConfig.deltaTime;\n}\n"}),r=t.createShaderModule({code:"struct SolverConfig {\n    gravity: vec3<f32>,\n    deltaTime: f32,\n};\n\n@group(0) @binding(0) var<storage, read_write> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, read_write> velocities: array<vec3<f32>>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n\n@compute @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= arrayLength(&positions)) {\n        return;\n    }\n\n    velocities[id] = (estimatedPositions[id] - positions[id]) / solverConfig.deltaTime;\n    positions[id] = estimatedPositions[id];\n}\n"}),c=t.createShaderModule({code:"@group(0) @binding(0) var<storage, read> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> indices: array<u32>;\n@group(0) @binding(2) var<storage, read_write> normals: array<atomic<i32>>;\n\n@compute @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= arrayLength(&indices) / 3u) {\n        return;\n    }\n\n    let a = indices[id*3u];\n    let b = indices[id*3u + 1u];\n    let c = indices[id*3u + 2u];\n\n    let face_normal = vec3<i32>(cross(positions[b] - positions[a], positions[c] - positions[a]) * 10000.0);\n\n    atomicAdd(&normals[a*4u], face_normal.x);\n    atomicAdd(&normals[a*4u + 1u], face_normal.y);\n    atomicAdd(&normals[a*4u + 2u], face_normal.z);\n\n    atomicAdd(&normals[b*4u], face_normal.x);\n    atomicAdd(&normals[b*4u + 1u], face_normal.y);\n    atomicAdd(&normals[b*4u + 2u], face_normal.z);\n\n    atomicAdd(&normals[c*4u], face_normal.x);\n    atomicAdd(&normals[c*4u + 1u], face_normal.y);\n    atomicAdd(&normals[c*4u + 2u], face_normal.z);\n}\n"});this.semiExplicitEulerPipeline=t.createComputePipeline({label:"semi-explicit-euler",layout:t.createPipelineLayout({label:"semi-explicit-euler",bindGroupLayouts:[t.createBindGroupLayout(_),t.createBindGroupLayout(N)]}),compute:{module:a,entryPoint:"main"}}),this.applyConstraintPipeline=t.createComputePipeline({label:"apply-constraint",layout:t.createPipelineLayout({label:"apply-constraint",bindGroupLayouts:[t.createBindGroupLayout(L),t.createBindGroupLayout(N),t.createBindGroupLayout(O)]}),compute:{module:o,entryPoint:"main"}}),this.updatePositionPipeline=t.createComputePipeline({label:"update-position",layout:t.createPipelineLayout({label:"update-position",bindGroupLayouts:[t.createBindGroupLayout(T),t.createBindGroupLayout(N)]}),compute:{module:r,entryPoint:"main"}}),this.updateNormalPipeline=t.createComputePipeline({label:"update-normal",layout:t.createPipelineLayout({label:"update-normal",bindGroupLayouts:[t.createBindGroupLayout(z)]}),compute:{module:c,entryPoint:"main"}})}solve(e,t){let i=this.objectStates[t.id];i||(i=new D(this.device,t),this.objectStates[t.id]=i),e.clearBuffer(t.geometry.vertices.normalBuffer);const s=e.beginComputePass();s.setBindGroup(1,this.configBindGroup);for(let e=0;e<this.config.subSteps;e++)this.semiExplicitEuler(s,t,i),this.applyConstraints(s,t,i),this.updatePositions(s,t,i);this.updateNormals(s,t,i),s.end()}semiExplicitEuler(e,t,i){e.setPipeline(this.semiExplicitEulerPipeline),e.setBindGroup(0,i.semiExplicitEulerBindGroup);const s=Math.sqrt(t.particles.count),n=Math.ceil(s/16),o=Math.ceil(s/16);e.dispatchWorkgroups(n,o)}applyConstraints(e,t,i){e.setPipeline(this.applyConstraintPipeline),e.setBindGroup(0,i.applyConstraintBindGroup),e.setBindGroup(1,this.configBindGroup);for(let s=0;s<t.constraints.colorCount;s++){e.setBindGroup(2,i.currentColorBindGroup,[256*s]);const n=Math.sqrt(t.constraints.colors[64*s+1]),o=Math.ceil(n/16),a=Math.ceil(n/16);e.dispatchWorkgroups(o,a)}}updatePositions(e,t,i){e.setPipeline(this.updatePositionPipeline),e.setBindGroup(0,i.updatePositionBindGroup),e.setBindGroup(1,this.configBindGroup);const s=Math.sqrt(t.particles.count),n=Math.ceil(s/16),o=Math.ceil(s/16);e.dispatchWorkgroups(n,o)}updateNormals(e,t,i){e.setPipeline(this.updateNormalPipeline),e.setBindGroup(0,i.updateNormalBindGroup);let s=Math.sqrt(t.geometry.triangles.count),n=Math.ceil(s/16),o=Math.ceil(s/16);e.dispatchWorkgroups(n,o)}}class D{constructor(e,t){this.semiExplicitEulerBindGroup=e.createBindGroup({label:"semi-explicit-euler",layout:e.createBindGroupLayout(_),entries:[{binding:0,resource:{buffer:t.geometry.vertices.positionBuffer}},{binding:1,resource:{buffer:t.particles.estimatedPositionBuffer}},{binding:2,resource:{buffer:t.particles.velocityBuffer}},{binding:3,resource:{buffer:t.particles.inverseMassBuffer}}]}),this.applyConstraintBindGroup=e.createBindGroup({label:"apply-constraint",layout:e.createBindGroupLayout(L),entries:[{binding:0,resource:{buffer:t.particles.estimatedPositionBuffer}},{binding:1,resource:{buffer:t.particles.inverseMassBuffer}},{binding:2,resource:{buffer:t.constraints.restValueBuffer}},{binding:3,resource:{buffer:t.constraints.complianceBuffer}},{binding:4,resource:{buffer:t.constraints.affectedParticleBuffer}}]}),this.updatePositionBindGroup=e.createBindGroup({label:"update-position",layout:e.createBindGroupLayout(T),entries:[{binding:0,resource:{buffer:t.geometry.vertices.positionBuffer}},{binding:1,resource:{buffer:t.particles.estimatedPositionBuffer}},{binding:2,resource:{buffer:t.particles.velocityBuffer}}]}),this.updateNormalBindGroup=e.createBindGroup({label:"update-normal",layout:e.createBindGroupLayout(z),entries:[{binding:0,resource:{buffer:t.geometry.vertices.positionBuffer}},{binding:1,resource:{buffer:t.geometry.triangles.indexBuffer}},{binding:2,resource:{buffer:t.geometry.vertices.normalBuffer}}]}),this.currentColorBindGroup=e.createBindGroup({label:"current-color",layout:e.createBindGroupLayout(O),entries:[{binding:0,resource:{buffer:t.constraints.colorBuffer,size:8,offset:0}}]})}}class k{constructor(t,i){this.canvas=t,this.device=i,this.paused=!0,this.stopped=!1,this.camera=new v(i,t,{width:t.width,height:t.height,distance:12,rotationX:25,rotationY:0}),this.renderer=new y(i,t),this.solver=new A(this.device,{deltaTime:1/60,subSteps:15,relaxation:1,gravity:e(0,-9.8,0)});const s=E(this.device,10,10,30,30);this.cloth=new g(this.device,s,{unit:.01,density:.27,stretchCompliance:0,bendCompliance:.3})}run(){return e=this,t=void 0,s=function*(){this.stopped=!1;const e=B.createTimer("tick");do{e.end(),yield new Promise(window.requestAnimationFrame),e.start(),this.cloth.uploadNeeded&&this.cloth.upload();const t=this.device.createCommandEncoder();this.paused||this.solver.solve(t,this.cloth),this.renderer.render(t,this.cloth,this.camera),this.device.queue.submit([t.finish()]),yield this.device.queue.onSubmittedWorkDone()}while(!this.stopped)},new((i=void 0)||(i=Promise))((function(n,o){function a(e){try{c(s.next(e))}catch(e){o(e)}}function r(e){try{c(s.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?n(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(a,r)}c((s=s.apply(e,t||[])).next())}));var e,t,i,s}stop(){this.stopped=!0}}const V=new class{constructor(){this.pending=[]}attach(e){this.el=e,setInterval((()=>this.flush()),100)}info(e){this.pending.push({date:new Date,message:e})}warn(e){this.pending.push({date:new Date,message:e})}error(e){this.pending.push({date:new Date,message:e})}flush(){this.pending.length&&(this.pending.forEach((e=>{const t=document.createElement("p"),i=e.date.toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"});let s=e.message;s=s.replace(/\n/g,"<br/>"),s=function(e){const t="**";let i="";for(;;){const s=e.indexOf(t);if(-1===s)return i+e;const n=e.slice(s+2).indexOf(t);if(-1===n)return i+e;i+=e.slice(0,s),i+=`<span class="strong">${e.slice(s+2,s+2+n)}</span>`,e=e.slice(s+2+n+2)}}(s),t.innerHTML=`<span class="date">${i}&nbsp&nbsp</span><span class="message">${s}</span>`,this.el.appendChild(t)})),this.el.scrollTop=this.el.scrollHeight,this.pending=[])}};class R{constructor(e,t){this.app=e,this.device=t,this.renderNeeded=!0,this.config={paused:!0,solver:{deltaTime:1/60,subSteps:10,relaxation:1},cloth:{unit:.01,density:.27,width:10,height:10,widthDivisions:100,heightDivisions:100,stretchCompliance:0,bendCompliance:.3}}}attach(e){this.el=e,this.updateApp(this.config,!0),setInterval((()=>this.run()),50),window.addEventListener("keypress",(e=>{switch(e.code){case"Space":this.togglePlay();break;case"KeyW":this.toggleWireframe()}}))}run(){if(!this.renderNeeded)return;this.el.innerHTML=this.render(),this.renderNeeded=!1;const e=document.getElementById("play"),t=document.getElementById("restart"),i=document.getElementById("apply");e.addEventListener("click",(e=>{e.preventDefault(),this.togglePlay()})),t.addEventListener("click",(e=>{e.preventDefault(),this.restartSimulation()})),i.addEventListener("click",(e=>{e.preventDefault(),this.apply()}))}render(){return`\n            <form>\n                <div>\n                    <div class="column">\n                        <label for="cloth-unit">\n                            <span>unit</span>\n                            <input type="number" id="cloth-unit" name="cloth-unit"\n                                value=${this.config.cloth.unit}\n                                step=0.001\n                                min=0.000001\n                                max=1000 />\n                        </label>\n                        <label for="cloth-density">\n                            <span>density</span>\n                            <input type="number" id="cloth-density" name="cloth-density"\n                                value=${this.config.cloth.density}\n                                step=0.001\n                                min=0.000001\n                                max=1000 />\n                        </label>\n                        <label for="cloth-width">\n                            <span>width</span>\n                            <input type="number" id="cloth-width" name="cloth-width"\n                                value=${this.config.cloth.width}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-height">\n                            <span>height</span>\n                            <input type="number" id="cloth-height" name="cloth-height"\n                                value=${this.config.cloth.height}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-width-divisions">\n                            <span>width-division</span>\n                            <input type="number" id="cloth-width-divisions" name="cloth-width-divisions"\n                                value=${this.config.cloth.widthDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-height-divisions">\n                            <span>height-division</span>\n                            <input type="number" id="cloth-height-divisions" name="cloth-height-divisions"\n                                value=${this.config.cloth.heightDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-stretch-compliance">\n                            <span>stretch compliance</span>\n                            <input type="number" id="cloth-stretch-compliance" name="cloth-stretch-compliance"\n                                value=${this.config.cloth.stretchCompliance}\n                                step=0.1\n                                min=0\n                                max=1 />\n                        </label>\n\n                        <label for="cloth-bend-compliance">\n                            <span>bend compliance</span>\n                            <input type="number" id="cloth-bend-compliance" name="cloth-bend-compliance"\n                                value=${this.config.cloth.bendCompliance}\n                                step=0.1\n                                min=0\n                                max=1 />\n                        </label>\n                    </div>\n\n                    <div class="column">\n                        <label for="solver-sub-steps">\n                            <span>sub-steps</span>\n                            <input type="number" id="solver-sub-steps" name="solver-sub-steps"\n                                value=${this.config.solver.subSteps}\n                                step=1\n                                min=1\n                                max=500 />\n                        </label>\n                    </div>\n                </div>\n\n                <div class="row">\n                    <button id="play">${this.config.paused?"Play":"Pause"}</button>\n                    <button id="restart">Restart</button>\n                    <button id="apply">Apply</button>\n                </div>\n            </form>\n        `}updateApp(e,t=!1){const i=e.cloth.width!==this.config.cloth.width||e.cloth.height!==this.config.cloth.height||e.cloth.widthDivisions!==this.config.cloth.widthDivisions||e.cloth.heightDivisions!==this.config.cloth.heightDivisions,s=e.cloth.stretchCompliance!==this.config.cloth.stretchCompliance||e.cloth.bendCompliance!==this.config.cloth.bendCompliance||e.cloth.unit!==this.config.cloth.unit||e.cloth.density!==this.config.cloth.density,n=e.solver.subSteps!==this.config.solver.subSteps;if(t||i||s){V.info("resetting the simulation with a new cloth geometry");const t=E(this.device,e.cloth.width,e.cloth.height,e.cloth.widthDivisions,e.cloth.heightDivisions);this.app.cloth=new g(this.device,t,{unit:e.cloth.unit,density:e.cloth.density,stretchCompliance:e.cloth.stretchCompliance,bendCompliance:e.cloth.bendCompliance})}(t||n||i||s)&&(this.app.solver=new A(this.device,e.solver))}buildConfiguration(){const e=new FormData(this.el.querySelector("form")),t=Object.assign(Object.assign({},this.config),{cloth:{unit:parseFloat(e.get("cloth-unit")),density:parseFloat(e.get("cloth-density")),width:parseFloat(e.get("cloth-width")),height:parseFloat(e.get("cloth-height")),widthDivisions:parseInt(e.get("cloth-width-divisions")),heightDivisions:parseInt(e.get("cloth-height-divisions")),stretchCompliance:parseFloat(e.get("cloth-stretch-compliance")),bendCompliance:parseFloat(e.get("cloth-bend-compliance"))},solver:Object.assign(Object.assign({},this.config.solver),{subSteps:parseInt(e.get("solver-sub-steps"))})});return this.renderNeeded=!0,t}apply(){const e=this.buildConfiguration();this.updateApp(e),this.config=e}restartSimulation(){const e=E(this.device,this.config.cloth.width,this.config.cloth.height,this.config.cloth.widthDivisions,this.config.cloth.heightDivisions);this.app.cloth=new g(this.device,e,{unit:this.config.cloth.unit,density:this.config.cloth.density,stretchCompliance:this.config.cloth.stretchCompliance,bendCompliance:this.config.cloth.bendCompliance})}togglePlay(){this.config.paused=!this.config.paused,this.app.paused=this.config.paused,this.renderNeeded=!0}toggleWireframe(){this.app.cloth.wireframe=!this.app.cloth.wireframe}}var Y=function(e,t,i,s){return new(i||(i=Promise))((function(n,o){function a(e){try{c(s.next(e))}catch(e){o(e)}}function r(e){try{c(s.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?n(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(a,r)}c((s=s.apply(e,t||[])).next())}))};(function(){return Y(this,void 0,void 0,(function*(){const e=navigator.gpu;if(!e)throw new Error("WebGPU is not supported on this browser.");const t=yield e.requestAdapter({powerPreference:"high-performance"});yield function(e){return Y(this,void 0,void 0,(function*(){const t=yield e.requestAdapterInfo(),i=`adapter info:\n    - vendor=${t.vendor}\n    - architecture=${t.architecture}\n    - description=${t.description}\n    `;console.debug(i),V.info(i);let s="adapter limits:\n";for(let t in e.limits)s+=` - ${t}: **${e.limits[t]}**\n`;console.debug(s),V.info(s)}))}(t);const i=yield t.requestDevice(),s=document.getElementById("app");s.width=1e3,s.height=512;const n=new k(s,i),o=new R(n,i);return V.attach(document.getElementById("logger")),B.attach(document.getElementById("monitor")),o.attach(document.getElementById("controller")),n.run()}))})().then((()=>V.info("done"))).catch((e=>console.error(e.toString()+"\n"+e.stack)))}();