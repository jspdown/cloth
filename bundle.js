!function(){"use strict";function e(e,t,i){return{x:e,y:t,z:i}}function t(e){return Math.sqrt(i(e))}function i(e){const t=e.x,i=e.y,n=e.z;return t*t+i*i+n*n}function n(e,t){return e.x+=t.x,e.y+=t.y,e.z+=t.z,e}function s(e,t){return{x:e.x-t.x,y:e.y-t.y,z:e.z-t.z}}function o(e,t){return{x:e.x*t,y:e.y*t,z:e.z*t}}function r(e,t){const i=e.x,n=e.y,s=e.z,o=t.x,r=t.y,a=t.z;return{x:n*a-s*r,y:s*o-i*a,z:i*r-n*o}}function a(e,t){const i=e.x,n=e.y,s=e.z,o=t.x,r=t.y,a=t.z;return e.x=n*a-s*r,e.y=s*o-i*a,e.z=i*r-n*o,e}function c(e){const t=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return t[12]=e.x,t[13]=e.y,t[14]=e.z,t}function l(e){return function(e,t){const i=Math.sin(t),n=Math.cos(t),s=e[0],o=e[1],r=e[2],a=e[3],c=e[4],l=e[5],h=e[6],u=e[7];return e[0]=s*n+c*i,e[1]=o*n+l*i,e[2]=r*n+h*i,e[3]=a*n+u*i,e[4]=c*n-s*i,e[5]=l*n-o*i,e[6]=h*n-r*i,e[7]=u*n-a*i,e}(function(e,t){const i=Math.sin(t),n=Math.cos(t),s=e[0],o=e[1],r=e[2],a=e[3],c=e[8],l=e[9],h=e[10],u=e[11];return e[0]=s*n-c*i,e[1]=o*n-l*i,e[2]=r*n-h*i,e[3]=a*n-u*i,e[8]=s*i+c*n,e[9]=o*i+l*n,e[10]=r*i+h*n,e[11]=a*i+u*n,e}(function(e,t){const i=Math.sin(t),n=Math.cos(t),s=e[4],o=e[5],r=e[6],a=e[7],c=e[8],l=e[9],h=e[10],u=e[11];return e[4]=s*n+c*i,e[5]=o*n+l*i,e[6]=r*n+h*i,e[7]=a*n+u*i,e[8]=c*n-s*i,e[9]=l*n-o*i,e[10]=h*n-r*i,e[11]=u*n-a*i,e}([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e.x),e.y),e.z)}function h(e,t){const i=e[0],n=e[1],s=e[2],o=e[3],r=e[4],a=e[5],c=e[6],l=e[7],h=e[8],u=e[9],f=e[10],d=e[11],p=e[12],g=e[13],m=e[14],v=e[15];let y=t[0],b=t[1],P=t[2],w=t[3];return e[0]=y*i+b*r+P*h+w*p,e[1]=y*n+b*a+P*u+w*g,e[2]=y*s+b*c+P*f+w*m,e[3]=y*o+b*l+P*d+w*v,y=t[4],b=t[5],P=t[6],w=t[7],e[4]=y*i+b*r+P*h+w*p,e[5]=y*n+b*a+P*u+w*g,e[6]=y*s+b*c+P*f+w*m,e[7]=y*o+b*l+P*d+w*v,y=t[8],b=t[9],P=t[10],w=t[11],e[8]=y*i+b*r+P*h+w*p,e[9]=y*n+b*a+P*u+w*g,e[10]=y*s+b*c+P*f+w*m,e[11]=y*o+b*l+P*d+w*v,y=t[12],b=t[13],P=t[14],w=t[15],e[12]=y*i+b*r+P*h+w*p,e[13]=y*n+b*a+P*u+w*g,e[14]=y*s+b*c+P*f+w*m,e[15]=y*o+b*l+P*d+w*v,e}class u{constructor(e,t){this.toString=()=>`(${this.x}, ${this.y}, ${this.z})`,this.buffer=e,this.offset=t}get x(){return this.buffer[this.offset]}set x(e){this.buffer[this.offset]=e}get y(){return this.buffer[this.offset+1]}set y(e){this.buffer[this.offset+1]=e}get z(){return this.buffer[this.offset+2]}set z(e){this.buffer[this.offset+2]=e}}u.alignedLength=4;class f{constructor(e,t,i){this.id=e,this.particles=t,this.offset=i}get position(){return new u(this.particles.positions,this.offset*u.alignedLength)}set position(e){this.particles.positions[this.offset*u.alignedLength]=e.x,this.particles.positions[this.offset*u.alignedLength+1]=e.y,this.particles.positions[this.offset*u.alignedLength+2]=e.z}get estimatedPosition(){return new u(this.particles.estimatedPositions,this.offset*u.alignedLength)}set estimatedPosition(e){this.particles.estimatedPositions[this.offset*u.alignedLength]=e.x,this.particles.estimatedPositions[this.offset*u.alignedLength+1]=e.y,this.particles.estimatedPositions[this.offset*u.alignedLength+2]=e.z}get deltaPosition(){return new u(this.particles.deltaPositions,this.offset*u.alignedLength)}set deltaPosition(e){this.particles.deltaPositions[this.offset*u.alignedLength]=e.x,this.particles.deltaPositions[this.offset*u.alignedLength+1]=e.y,this.particles.deltaPositions[this.offset*u.alignedLength+2]=e.z}get velocity(){return new u(this.particles.velocities,this.offset*u.alignedLength)}set velocity(e){this.particles.velocities[this.offset*u.alignedLength]=e.x,this.particles.velocities[this.offset*u.alignedLength+1]=e.y,this.particles.velocities[this.offset*u.alignedLength+2]=e.z}get inverseMass(){return this.particles.inverseMasses[this.offset]}set inverseMass(e){this.particles.inverseMasses[this.offset]=e}get constraintCount(){return this.particles.constraintCounts[this.offset]}set constraintCount(e){this.particles.constraintCounts[this.offset]=e}}class d{constructor(e){this.positions=new Float32Array(e*u.alignedLength),this.velocities=new Float32Array(e*u.alignedLength),this.estimatedPositions=new Float32Array(e*u.alignedLength),this.deltaPositions=new Float32Array(e*u.alignedLength),this.inverseMasses=new Float32Array(e),this.constraintCounts=new Float32Array(e),this.count=0,this.max=e}add(e){if(this.count+1>this.max)return new Error("max number of particles reached");const t=new f(this.count,this,this.count);t.position=e.position,t.estimatedPosition=e.estimatedPosition,t.deltaPosition=e.deltaPosition,t.velocity=e.velocity,t.inverseMass=e.inverseMass,this.count++}get(e){return new f(e,this,e)}forEach(e){for(let t=0;t<this.count;t++)e(new f(t,this,t))}}class p{constructor(e,t){this.constraints=e,this.offset=t}get p1(){return this.constraints.affectedParticles[2*this.offset]}set p1(e){this.constraints.affectedParticles[2*this.offset]=e}get p2(){return this.constraints.affectedParticles[2*this.offset+1]}set p2(e){this.constraints.affectedParticles[2*this.offset+1]=e}get restValue(){return this.constraints.restValues[this.offset]}set restValue(e){this.constraints.restValues[this.offset]=e}get compliance(){return this.constraints.compliances[this.offset]}set compliance(e){this.constraints.compliances[this.offset]=e}unref(){return{p1:this.p1,p2:this.p2,compliance:this.compliance,restValue:this.restValue}}}class g{constructor(e){this.restValues=new Float32Array(e),this.compliances=new Float32Array(e),this.affectedParticles=new Float32Array(2*e),this.colors=new Uint32Array([0,0]),this.adjacency=[],this.count=0,this.max=e}add(e,t,i){if(this.count+1>this.max)throw new Error("max number of constraints reached");const n=new p(this,this.count);n.compliance=i,n.restValue=function(e,t){const i=e.x,n=e.y,s=e.z,o=t.x,r=t.y,a=t.z;return Math.sqrt((i-o)*(i-o)+(n-r)*(n-r)+(s-a)*(s-a))}(e.position,t.position),n.p1=e.id,n.p2=t.id,e.constraintCount++,t.constraintCount++,this.addAdjacency(e.id,t.id),this.addAdjacency(t.id,e.id),this.colors[this.colors.length-1]++,this.count++}color(){const e=this.adjacency.length,t=this.restValues.length,i=[],n=new Array(t).fill(!1),s=new Array(e).fill(!1);let o=t;for(;o;){const e=[];s.fill(!1);for(let i=0;i<t;i++){if(n[i])continue;const t=this.affectedParticles[2*i],r=this.affectedParticles[2*i+1];s[t]||s[r]||(e.push(i),n[i]=!0,o--,s[t]=!0,s[r]=!0)}i.push(e)}const r=new g(t),a=new Uint32Array(2*i.length);let c=0;for(let e=0;e<i.length;e++){a[2*e]=c;for(let t=0;t<i[e].length;t++)r.set(c,this.get(i[e][t])),c++;a[2*e+1]=c-a[2*e]}this.restValues=r.restValues,this.compliances=r.compliances,this.affectedParticles=r.affectedParticles,this.colors=a}get(e){return new p(this,e)}set(e,t){const i=new p(this,e);i.compliance=t.compliance,i.restValue=t.restValue,i.p1=t.p1,i.p2=t.p2}forEach(e){for(let t=0;t<this.count;t++)e(new p(this,t))}addAdjacency(e,t){if(e>this.adjacency.length-1)for(let t=this.adjacency.length;t<=e;t++)this.adjacency.push([]);this.adjacency[e].push(t)}}const m=new class{constructor(){this.pending=[]}attach(e){this.el=e,setInterval((()=>this.flush()),100)}flush(){this.pending.length&&(this.pending.forEach((e=>{const t=document.createElement("p"),i=e.date.toLocaleTimeString("en-US",{hour12:!1,hour:"2-digit",minute:"2-digit",second:"2-digit"});let n=e.message;n=this.replaceCarriageReturns(n),n=this.replaceStrongMarkers(n),t.innerHTML=`<span class="date">${i}&nbsp&nbsp</span><span class="message">${n}</span>`,this.el.appendChild(t)})),this.el.scrollTop=this.el.scrollHeight,this.pending=[])}replaceCarriageReturns(e){return e.replace(/\n/g,"<br/>")}replaceStrongMarkers(e){const t="**";let i="";for(;;){const n=e.indexOf(t);if(-1===n)return i+e;const s=e.slice(n+t.length).indexOf(t);if(-1===s)return i+e;i+=e.slice(0,n),i+=`<span class="strong">${e.slice(n+t.length,n+t.length+s)}</span>`,e=e.slice(n+t.length+s+t.length)}}info(e){this.pending.push({date:new Date,message:e})}warn(e){this.pending.push({date:new Date,message:e})}error(e){this.pending.push({date:new Date,message:e})}};class v{constructor(e,t,i,n,s){this._config=Object.assign(Object.assign({},v.defaultConfig),i),this.device=e,this.geometry=t,this.updated=!1,this._position={x:0,y:0,z:0},this._rotation={x:0,y:0,z:0},n&&(this.position=n),s&&(this.rotation=s),this.renderPipeline=null}set geometry(e){this._geometry=e,this.particles=y(this._geometry,this._config.unit,this._config.density),this.constraints=b(this._geometry,this.particles,this._config.stretchCompliance,this._config.bendCompliance),m.info(`vertices: **${this._geometry.vertices.count}**`),m.info(`triangles: **${this._geometry.topology.triangles.length}**`),m.info(`edges: **${this._geometry.topology.edges.length}**`),m.info(`constraints: **${this.constraints.count}**`)}get geometry(){return this._geometry}set config(e){const t=Object.assign(Object.assign({},v.defaultConfig),e),i=t.unit!==this._config.unit||t.density!==this._config.density,n=t.stretchCompliance!==this._config.stretchCompliance||t.bendCompliance!==this._config.bendCompliance||t.density;(n||i)&&(Object.keys(t).forEach((e=>{const i=this._config[e],n=t[e];var s;n!==i&&m.info(`${e}: **${s=n,"object"==typeof s?JSON.stringify(s):s.toString()}**`)})),i&&(this.particles=y(this._geometry,t.unit,t.density)),n&&(this.constraints=b(this._geometry,this.particles,t.stretchCompliance,t.bendCompliance)),this._config=t)}get config(){return this._config}set position(e){this._position=e,this.updated=!0}get position(){return this._position}set rotation(e){this._rotation=e,this.updated=!0}get rotation(){return this._rotation}set wireframe(e){this._geometry.wireframe=e,this.renderPipeline=null}get wireframe(){return this._geometry.wireframe}updatePositionsAndNormals(){this._geometry.vertices.forEach((e=>{const t=this.particles.get(e.id);e.position=t.position,e.normal={x:0,y:0,z:0}}));for(let e of this._geometry.topology.triangles){const t=this._geometry.vertices.get(e.a),i=this._geometry.vertices.get(e.b),o=this._geometry.vertices.get(e.c),a=r(s(i.position,t.position),s(o.position,t.position));n(t.normal,a),n(i.normal,a),n(o.normal,a)}this._geometry.vertices.forEach((e=>{!function(e){let t=i(e);t>0&&(t=1/Math.sqrt(t)),e.x*=t,e.y*=t,e.z*=t}(e.normal),e.color=e.normal})),this._geometry.upload()}getRenderPipeline(e){if(this.renderPipeline)return this.updateUniforms(),this.renderPipeline;const t=this.device.createShaderModule({code:"struct Output {\n    @builtin(position) Position: vec4<f32>,\n    @location(0) Normal: vec3<f32>,\n    @location(1) Color: vec3<f32>,\n};\n\nstruct Camera {\n    projection: mat4x4<f32>,\n    view: mat4x4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> camera: Camera;\n@group(1) @binding(0) var<uniform> model: mat4x4<f32>;\n\n@stage(vertex)\nfn main(\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @location(2) color: vec3<f32>) -> Output {\n\n    var output: Output;\n\n    output.Normal = normal;\n    output.Color = color;\n    output.Position = camera.projection * camera.view * model * vec4<f32>(position, 1.0);\n\n    return output;\n}\n"}),i=this.device.createShaderModule({code:"@stage(fragment)\nfn main(\n    @location(0) normal: vec3<f32>,\n    @location(1) color: vec3<f32>) -> @location(0) vec4<f32> {\n\n    return vec4<f32>(color, 1.0);\n}\n"}),n=this.computeUniform();var s;this.uniformBuffer=this.device.createBuffer({size:(s=n.byteLength,s+3&-4),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.uniformBuffer.getMappedRange()).set(n),this.uniformBuffer.unmap();const o=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]});this.uniformBindGroup=this.device.createBindGroup({layout:o,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]});const r=this.device.createPipelineLayout({bindGroupLayouts:[e.uniformBindGroupLayout,o]});return this.renderPipeline=this.device.createRenderPipeline({layout:r,vertex:{module:t,entryPoint:"main",buffers:[{attributes:[{shaderLocation:0,offset:0,format:"float32x3"},{shaderLocation:1,offset:12,format:"float32x3"},{shaderLocation:2,offset:24,format:"float32x3"}],arrayStride:36,stepMode:"vertex"}]},fragment:{module:i,entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{frontFace:"cw",cullMode:"none",topology:this._geometry.primitive},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.renderPipeline}updateUniforms(){const e=this.computeUniform();this.device.queue.writeBuffer(this.uniformBuffer,0,e,0,e.length)}computeUniform(){return new Float32Array(h(c(this.position),l(this.rotation)))}}function y(e,i,n){const o=new d(e.vertices.count);e.vertices.forEach((e=>{o.add({position:e.position,velocity:{x:0,y:0,z:0},estimatedPosition:{x:0,y:0,z:0},deltaPosition:{x:0,y:0,z:0},inverseMass:0,constraintCount:0})}));for(let r of e.topology.triangles){const e=o.get(r.a),c=o.get(r.b),l=o.get(r.c),h=1/(i*(.5*t(a(s(c.position,e.position),s(l.position,e.position))))*n)/3;e.inverseMass+=h,c.inverseMass+=h,l.inverseMass+=h}return o.forEach((e=>{0===e.position.z&&(e.inverseMass=0)})),o}function b(e,t,i,n){const s=[];for(let t of e.topology.edges)s.push({compliance:i,p1:t.start,p2:t.end});for(let t of e.topology.edges){if(1==t.triangles.length)continue;if(2!=t.triangles.length)throw new Error(`Non-manifold mesh: ${t.start}-${t.end} shared with ${t.triangles.length} triangles`);const i=e.topology.triangles[t.triangles[0]],o=e.topology.triangles[t.triangles[1]];let r,a;r=i.a!=t.start&&i.a!=t.end?i.a:i.b!=t.start&&i.b!=t.end?i.b:i.c,a=o.a!=t.start&&o.a!=t.end?o.a:o.b!=t.start&&o.b!=t.end?o.b:o.c,s.push({compliance:n,p1:r,p2:a})}!function(e){for(let t=e.length-1;t>=1;t--){const i=Math.floor(Math.random()*(t+1)),n=e[i];e[i]=e[t],e[t]=n}}(s);const o=new g(s.length);for(let e of s)o.add(t.get(e.p1),t.get(e.p2),e.compliance);return o}function P(e){return e*(Math.PI/180)}v.defaultConfig={unit:.01,density:.27,stretchCompliance:0,bendCompliance:.3};class w{constructor(e,t,i){this.device=t,this.config=Object.assign({fovy:Math.PI/4,near:1e-4,far:1e3,zoomSpeed:2,distance:5},i),this.zoom=0,this.dragging=!1,this.rotateX=90,this.rotateY=0,this.x=0,this.y=0,this.lastX=0,this.lastY=0,this.limitX=85,this.uniformBuffer=t.createBuffer({size:128,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroupLayout=t.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform"}}]}),this.uniformBindGroup=t.createBindGroup({layout:this.uniformBindGroupLayout,entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]}),e.addEventListener("mousedown",(()=>this.onMouseButtonPressed())),e.addEventListener("mouseup",(()=>this.onMouseButtonReleased())),e.addEventListener("wheel",(e=>this.onMouseWheel(e.deltaY))),e.addEventListener("mousemove",(e=>this.onMouseMove(e.clientX,e.clientY))),this.updateUniform()}onMouseButtonPressed(){this.dragging=!0,this.lastX=this.x,this.lastY=this.y}onMouseButtonReleased(){this.dragging=!1}onMouseMove(e,t){this.x=e,this.y=t,this.dragging&&this.drag(this.x,this.y)}onMouseWheel(e){this.zoom+=e<0?-1:1,this.updateUniform()}drag(e,t){let i=90/this.config.height,n=180/this.config.width,s=this.rotateX+i*(t-this.lastY),o=this.rotateY+n*(e-this.lastX);(s<-this.limitX||s>this.limitX)&&(s=this.limitX),this.lastX=e,this.lastY=t,(Math.abs(s-this.rotateX)>.01||Math.abs(o-this.rotateY)>.01)&&(this.rotateX=s,this.rotateY=o),this.updateUniform()}updateUniform(){const t=function(e,t,i,n){const s=1/Math.tan(e/2),o=1/(t-i),r=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];return r[0]=s/n,r[5]=s,r[10]=(i+t)*o,r[11]=-1,r[14]=2*i*t*o,r}(this.config.fovy,this.config.near,this.config.far,this.config.width/this.config.height),i=e(0,0,-Math.pow(.95,-this.zoom)*this.config.zoomSpeed*this.config.distance),n=e(P(this.rotateX),P(this.rotateY),0),s=h(c(i),l(n)),o=new Float32Array(32);o.set(t,0),o.set(s,16),this.device.queue.writeBuffer(this.uniformBuffer,0,o,0,o.length)}}class B{constructor(e,t){this.device=t,this.context=e.getContext("webgpu"),this.context.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,compositingAlphaMode:"opaque"});const i={size:[e.width,e.height,1],dimension:"2d",format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC},n=this.device.createTexture(i);this.depthTextureView=n.createView()}render(e,t,i){const n={colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:.83,g:.85,b:.86,a:1},storeOp:"store"}],depthStencilAttachment:{view:this.depthTextureView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},s=this.device.createCommandEncoder(),o=s.beginRenderPass(n),{width:r,height:a}=this.context.canvas;o.setPipeline(t),o.setViewport(0,0,r,a,0,1),o.setScissorRect(0,0,r,a),o.setVertexBuffer(0,e.vertexBuffer),o.setIndexBuffer(e.indexBuffer,"uint32");for(let e=0;e<i.length;e++)o.setBindGroup(e,i[e]);o.drawIndexed(e.indexCount),o.end(),this.device.queue.submit([s.finish()])}}class x{constructor(e,t){this.name=e,this.deltas=[],this.el=t}start(){this._start=window.performance.now()}end(){const e=window.performance.now()-this._start;this.deltas.push(e),this.deltas.length>5&&this.deltas.splice(0,this.deltas.length-5)}render(){const e=this.deltas.reduce(((e,t)=>t+e),0)/this.deltas.length;this.el.innerHTML=`\n            <span class="timer">\n                ${this.name}:\n            </span>\n            <span class="strong">${e.toFixed(3)}</span> ms\n        `}}const C=new class{attach(e){const t=document.createElement("ul");e.appendChild(t),this.el=t,this.timers=[],setInterval((()=>this.render()),200)}createTimer(e){const t=document.createElement("li");this.el.appendChild(t);const i=new x(e,t);return this.timers.push(i),i}render(){this.timers.forEach((e=>e.render()))}};class U{constructor(e,t){this.toString=()=>`(${this.x}, ${this.y}, ${this.z})`,this.buffer=e,this.offset=t}get x(){return this.buffer[this.offset]}set x(e){this.buffer[this.offset]=e}get y(){return this.buffer[this.offset+1]}set y(e){this.buffer[this.offset+1]=e}get z(){return this.buffer[this.offset+2]}set z(e){this.buffer[this.offset+2]=e}}class G{constructor(e,t,i){this.id=e,this.buffer=t,this.offset=i}get position(){const e=this.offset+G.positionOffset;return new U(this.buffer,e)}set position(e){const t=this.offset+G.positionOffset;this.buffer[t]=e.x,this.buffer[t+1]=e.y,this.buffer[t+2]=e.z}get normal(){const e=this.offset+G.normalOffset;return new U(this.buffer,e)}set normal(e){const t=this.offset+G.normalOffset;this.buffer[t]=e.x,this.buffer[t+1]=e.y,this.buffer[t+2]=e.z}get color(){const e=this.offset+G.colorOffset;return new U(this.buffer,e)}set color(e){const t=this.offset+G.colorOffset;this.buffer[t]=e.x,this.buffer[t+1]=e.y,this.buffer[t+2]=e.z}}G.positionOffset=0,G.normalOffset=3,G.colorOffset=6,G.components=9;class S{constructor(e){this.buffer=new Float32Array(e*G.components),this.count=0}add(e){const t=this.count,i=this.count*G.components,n=new G(t,this.buffer,i);n.position=e.position,n.normal=e.normal,n.color=e.color,this.count++}get(e){return new G(e,this.buffer,e*G.components)}forEach(e){for(let t=0;t<this.count;t++)e(new G(t,this.buffer,t*G.components))}}class _{constructor(e,t,i){this.vertices=t,this.defaultIndices=i,this.topology=function(e,t){const i=t.length/3,n=new Array(e.count),s={},o=[],r=[],a=(e,t)=>{n[e]||(n[e]=[]),n[e].push(t)};for(let e=0;e<i;e++){const i={a:t[3*e],b:t[3*e+1],c:t[3*e+2]};a(i.a,e),a(i.b,e),a(i.c,e);const n=[{start:Math.min(i.a,i.b),end:Math.max(i.a,i.b)},{start:Math.min(i.b,i.c),end:Math.max(i.b,i.c)},{start:Math.min(i.c,i.a),end:Math.max(i.c,i.a)}];o.push(i);for(let t of n){const i=`${t.start}-${t.end}`;s[i]?r[s[i]].triangles.push(e):(r.push({start:t.start,end:t.end,triangles:[e]}),s[i]=r.length-1)}}return{triangles:o,edges:r}}(t,i),this.primitive="triangle-list",this.device=e,this._wireframe=!1,this.defaultIndexBuffer=e.createBuffer({size:E(this.defaultIndices.byteLength),usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Uint32Array(this.defaultIndexBuffer.getMappedRange()).set(this.defaultIndices),this.defaultIndexBuffer.unmap(),this.vertexBuffer=e.createBuffer({size:E(this.vertices.buffer.byteLength),usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(this.vertices.buffer),this.vertexBuffer.unmap()}get indexBuffer(){return this.wireframe?this.wireframeIndexBuffer:this.defaultIndexBuffer}get indexCount(){return this.wireframe?this.wireframeIndices.length:this.defaultIndices.length}set wireframe(e){this._wireframe!==e&&(this._wireframe=e,e?(this.wireframeIndices||(this.wireframeIndices=function(e){const t=new Uint32Array(2*e.edges.length);let i=0;for(let n of e.edges)t[i]=n.start,t[i+1]=n.end,i+=2;return t}(this.topology),this.wireframeIndexBuffer=this.device.createBuffer({size:E(this.wireframeIndices.byteLength),usage:GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST})),this.device.queue.writeBuffer(this.wireframeIndexBuffer,0,this.wireframeIndices,0,this.wireframeIndices.length),this.primitive="line-list"):(this.device.queue.writeBuffer(this.defaultIndexBuffer,0,this.defaultIndices,0,this.defaultIndices.length),this.primitive="triangle-list"))}get wireframe(){return this._wireframe}upload(){this.device.queue.writeBuffer(this.vertexBuffer,0,this.vertices.buffer,0,this.vertices.buffer.length)}}function M(t,i,n,s,o){const r=i/s,a=n/o;m.info(`plane geometry: size=(**${i}**, **${n}**) divisions=(**${s}**, **${o}**)`);const c=new S((o+1)*(s+1)),l=new Uint32Array(2*o*s*3);let h=0;for(let t=0;t<o+1;t++){const i=t*a;for(let t=0;t<s+1;t++){const n=t*r;c.add({position:e(n,0,i),normal:e(0,1,0),color:e(0,1,0)})}}for(let e=0;e<o;e++)for(let t=0;t<s;t++){const i=t+(s+1)*e,n=t+(s+1)*(e+1),o=t+1+(s+1)*(e+1),r=t+1+(s+1)*e;l.set([i,n,r],h),h+=3,l.set([n,o,r],h),h+=3}return new _(t,c,l)}function E(e){return e+3&-4}var z;!function(e){e.Jacobi="jacobi",e.GaussSeidel="gauss-seidel"}(z||(z={}));class T{constructor(t){this.config=Object.assign({deltaTime:1/60,subSteps:10,gravity:e(0,-9.8,0),relaxation:1,method:z.GaussSeidel},t),this.objects=[]}add(e){this.objects.push(e)}solve(){return e=this,t=void 0,r=function*(){const e=this.config.deltaTime/this.config.subSteps,t=1/e,i=o(this.config.gravity,e);for(let r of this.objects){for(let a=0;a<this.config.subSteps;a++)r.particles.forEach((t=>{var s,r;t.inverseMass>0&&n(t.velocity,i),t.estimatedPosition=(s=t.position,r=o(t.velocity,e),{x:s.x+r.x,y:s.y+r.y,z:s.z+r.z})})),r.constraints.forEach((t=>{O(t,r.particles,this.config.method,e)})),r.particles.forEach((e=>{if(this.config.method===z.Jacobi){if(!e.constraintCount)return;i=e.deltaPosition,r=this.config.relaxation/e.constraintCount,i.x*=r,i.y*=r,i.z*=r,n(e.estimatedPosition,e.deltaPosition),e.deltaPosition={x:0,y:0,z:0}}var i,r;e.velocity=o(s(e.estimatedPosition,e.position),t),e.position=e.estimatedPosition}));r.updatePositionsAndNormals()}},new((i=void 0)||(i=Promise))((function(n,s){function o(e){try{c(r.next(e))}catch(e){s(e)}}function a(e){try{c(r.throw(e))}catch(e){s(e)}}function c(e){var t;e.done?n(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(o,a)}c((r=r.apply(e,t||[])).next())}));var e,t,i,r}}function O(e,i,r,a){const c=i.get(e.p1),l=i.get(e.p2),h=c.inverseMass+l.inverseMass;if(0===h)return;const u=e.compliance/(a*a),f=s(c.estimatedPosition,l.estimatedPosition);let d=t(f);if(d<1e-6)return;const p=function(e,t){if(!t)throw new Error("divideByScalar: division by 0");return{x:e.x/t,y:e.y/t,z:e.z/t}}(f,d),g=-(d-e.restValue)/(h+u),m=o(p,g*c.inverseMass),v=o(p,-g*l.inverseMass);r===z.Jacobi?(n(c.deltaPosition,m),n(l.deltaPosition,v)):(n(c.estimatedPosition,m),n(l.estimatedPosition,v))}class L{constructor(t,i){this.canvas=t,this.device=i,this.paused=!0,this.stopped=!1,this.camera=new w(t,i,{width:t.width,height:t.height}),this.renderer=new B(t,i),this.solver=new T({deltaTime:1/60,subSteps:15,relaxation:1,method:z.GaussSeidel});const n=M(this.device,10,10,30,30);this.cloth=new v(this.device,n,{stretchCompliance:0,bendCompliance:.3},e(-5,0,0)),this.solver.add(this.cloth)}run(){return e=this,t=void 0,n=function*(){this.stopped=!1;const e=C.createTimer("tick"),t=C.createTimer("physic");do{yield new Promise(window.requestAnimationFrame),e.start(),this.paused||(t.start(),yield this.solver.solve(),t.end());const i=this.cloth.getRenderPipeline(this.camera);i&&this.renderer.render(this.cloth.geometry,i,[this.camera.uniformBindGroup,this.cloth.uniformBindGroup]),e.end()}while(!this.stopped)},new((i=void 0)||(i=Promise))((function(s,o){function r(e){try{c(n.next(e))}catch(e){o(e)}}function a(e){try{c(n.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(r,a)}c((n=n.apply(e,t||[])).next())}));var e,t,i,n}stop(){this.stopped=!0}}var A;class ${constructor(t,i,n){this.device=i,this.config=Object.assign({deltaTime:1/60,subSteps:10,gravity:e(0,-9.8,0),relaxation:1},t),this.objects=[];const s=i.createShaderModule({code:"struct SolverConfig {\n    deltaTime: f32,\n    constraintCount: f32,\n    particlesCount: f32,\n    gravity: vec3<f32>,\n};\n\nstruct ColorConfig {\n    start: u32,\n    count: u32,\n}\n\n@group(0) @binding(0) var<storage, read_write> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> inverseMasses: array<f32>;\n@group(0) @binding(2) var<storage, read> restValues: array<f32>;\n@group(0) @binding(3) var<storage, read> compliances: array<f32>;\n@group(0) @binding(4) var<storage, read> affectedParticles: array<f32>;\n\n@group(1) @binding(0) var<uniform> solverConfig: SolverConfig;\n@group(2) @binding(0) var<uniform> colorConfig: ColorConfig;\n\n@stage(compute) @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= u32(colorConfig.count)) {\n        return;\n    }\n\n    var constraint_id = colorConfig.start + id;\n    var p1_id = u32(affectedParticles[constraint_id * 2u]);\n    var p2_id = u32(affectedParticles[constraint_id * 2u + 1u]);\n\n    var w1 = inverseMasses[p1_id];\n    var w2 = inverseMasses[p2_id];\n\n    var sumWeight = w1 + w2;\n    if (sumWeight <= 0.0) {\n        return;\n    }\n\n    var alphaTilde = compliances[constraint_id] / (solverConfig.deltaTime * solverConfig.deltaTime);\n    var p1p2 = estimatedPositions[p1_id] - estimatedPositions[p2_id];\n\n    var distance = length(p1p2);\n\n    if (distance < 0.0000001) {\n        return;\n    }\n\n    var grad = p1p2 / distance;\n    var c = distance - restValues[constraint_id];\n    var lagrangeMultiplier = -c / (sumWeight + alphaTilde);\n\n    estimatedPositions[p1_id] += grad * lagrangeMultiplier * w1;\n    estimatedPositions[p2_id] += grad * -lagrangeMultiplier * w2;\n}\n"}),o=i.createShaderModule({code:"struct Config {\n    deltaTime: f32,\n    constraintCount: f32,\n    particlesCount: f32,\n    gravity: vec3<f32>,\n};\n\n@group(0) @binding(0) var<storage, read> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, write> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, read_write> velocities: array<vec3<f32>>;\n@group(0) @binding(3) var<storage, read> inverseMasses: array<f32>;\n\n@group(1) @binding(0) var<uniform> config: Config;\n\n@stage(compute) @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= u32(config.particlesCount)) {\n        return;\n    }\n\n    if (inverseMasses[id] > 0.0) {\n        velocities[id] += config.gravity * config.deltaTime;\n    }\n\n    estimatedPositions[id] = positions[id] + velocities[id] * config.deltaTime;\n}\n"}),r=i.createShaderModule({code:"struct Config {\n    deltaTime: f32,\n    constraintCount: f32,\n    particlesCount: f32,\n    gravity: vec3<f32>,\n};\n\n@group(0) @binding(0) var<storage, read_write> positions: array<vec3<f32>>;\n@group(0) @binding(1) var<storage, read> estimatedPositions: array<vec3<f32>>;\n@group(0) @binding(2) var<storage, write> velocities: array<vec3<f32>>;\n\n@group(1) @binding(0) var<uniform> config: Config;\n\n@stage(compute) @workgroup_size(16, 16)\nfn main(@builtin(num_workgroups) workgroup_size: vec3<u32>, @builtin(global_invocation_id) global_id: vec3<u32>) {\n    let w = workgroup_size.x * 16u;\n    let h = workgroup_size.y * 16u;\n\n    let id = global_id.x\n        + (global_id.y * w)\n        + (global_id.z * w * h);\n\n    // Guard against out-of-bounds work group sizes.\n    if (id >= u32(config.particlesCount)) {\n        return;\n    }\n\n    velocities[id] = (estimatedPositions[id] - positions[id]) / config.deltaTime;\n    positions[id] = estimatedPositions[id];\n}\n"});this.configLayout=i.createBindGroupLayout({label:"config-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.semiExplicitEulerPipeline=i.createComputePipeline({label:"semi-explicit-euler-compute-pipeline",layout:i.createPipelineLayout({label:"semi-explicit-euler-pipeline-layout",bindGroupLayouts:[i.createBindGroupLayout({label:"semi-explicit-euler-data-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),this.configLayout]}),compute:{module:o,entryPoint:"main"}}),this.applyConstraintPipeline=i.createComputePipeline({label:"apply-constraint-compute-pipeline",layout:i.createPipelineLayout({label:"apply-constraint-pipeline-layout",bindGroupLayouts:[i.createBindGroupLayout({label:"apply-constraint-data-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}]}),this.configLayout,i.createBindGroupLayout({label:"color-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]})]}),compute:{module:s,entryPoint:"main"}}),this.updatePositionPipeline=i.createComputePipeline({label:"update-position-compute-pipeline",layout:i.createPipelineLayout({label:"update-position-pipeline-layout",bindGroupLayouts:[i.createBindGroupLayout({label:"update-position-data-layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.configLayout]}),compute:{module:r,entryPoint:"main"}})}solve(){return e=this,t=void 0,n=function*(){for(let e of this.objects){const t=this.device.createBuffer({label:"position-read-buffer",size:I(4*e.cloth.particles.positions.length),usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),i=this.device.createCommandEncoder();for(let t=0;t<this.config.subSteps;t++)this.semiExplicitEuler(i,e),this.applyConstraints(i,e),this.updatePositions(i,e);i.copyBufferToBuffer(e.positionBuffer,0,t,0,e.cloth.particles.positions.byteLength),this.device.queue.submit([i.finish()]),yield t.mapAsync(GPUMapMode.READ),e.cloth.particles.positions.set(new Float32Array(t.getMappedRange())),t.unmap(),e.cloth.updatePositionsAndNormals()}},new((i=void 0)||(i=Promise))((function(s,o){function r(e){try{c(n.next(e))}catch(e){o(e)}}function a(e){try{c(n.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(r,a)}c((n=n.apply(e,t||[])).next())}));var e,t,i,n}semiExplicitEuler(e,t){const i=e.beginComputePass();i.setPipeline(this.semiExplicitEulerPipeline),i.setBindGroup(0,t.eulerBindGroup),i.setBindGroup(1,t.configBindGroup);const n=Math.sqrt(t.cloth.particles.count),s=Math.ceil(n/16),o=Math.ceil(n/16);i.dispatchWorkgroups(s,o),i.end()}applyConstraints(e,t){const i=t.cloth.constraints.colors;for(let n=0;n<i.length/2;n++){e.copyBufferToBuffer(t.colorWriteBuffer,2*n*4,t.colorBuffer,0,8);const s=e.beginComputePass();s.setPipeline(this.applyConstraintPipeline),s.setBindGroup(0,t.constraintBindGroup),s.setBindGroup(1,t.configBindGroup),s.setBindGroup(2,t.colorBindGroup);const o=Math.sqrt(i[2*n+1]),r=Math.ceil(o/16),a=Math.ceil(o/16);s.dispatchWorkgroups(r,a),s.end()}}updatePositions(e,t){const i=e.beginComputePass();i.setPipeline(this.updatePositionPipeline),i.setBindGroup(0,t.positionBindGroup),i.setBindGroup(1,t.configBindGroup);const n=Math.sqrt(t.cloth.particles.count),s=Math.ceil(n/16),o=Math.ceil(n/16);i.dispatchWorkgroups(s,o),i.end()}add(e){e.constraints.color();const t=new Float32Array([this.config.deltaTime/this.config.subSteps,e.constraints.count,e.particles.count,0,this.config.gravity.x,this.config.gravity.y,this.config.gravity.z]),i=this.device.createBuffer({label:"config-buffer",size:I(4*t.length),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),n=this.device.createBuffer({label:"position-buffer",size:I(4*e.particles.positions.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),s=this.device.createBuffer({label:"estimated-position-buffer",size:I(4*e.particles.estimatedPositions.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),o=this.device.createBuffer({label:"velocity-buffer",size:I(4*e.particles.velocities.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}),r=this.device.createBuffer({label:"inverse-masses-buffer",size:I(4*e.particles.inverseMasses.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),a=this.device.createBuffer({label:"rest-values-buffer",size:I(4*e.constraints.restValues.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),c=this.device.createBuffer({label:"compliances-buffer",size:I(4*e.constraints.compliances.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),l=this.device.createBuffer({label:"affected-particles-buffer",size:I(4*e.constraints.affectedParticles.length),usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),h=this.device.createBuffer({label:"color-buffer",size:I(8),usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),u=this.device.createBuffer({label:"color-write-buffer",size:I(e.constraints.colors.byteLength),usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});this.writeAllBuffer(i,t),this.writeAllBuffer(n,e.particles.positions),this.writeAllBuffer(o,e.particles.velocities),this.writeAllBuffer(r,e.particles.inverseMasses),this.writeAllBuffer(a,e.constraints.restValues),this.writeAllBuffer(c,e.constraints.compliances),this.writeAllBuffer(l,e.constraints.affectedParticles),this.writeAllBuffer(u,e.constraints.colors);const f=this.device.createBindGroup({layout:this.semiExplicitEulerPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:r}}]}),d=this.device.createBindGroup({layout:this.applyConstraintPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:s}},{binding:1,resource:{buffer:r}},{binding:2,resource:{buffer:a}},{binding:3,resource:{buffer:c}},{binding:4,resource:{buffer:l}}]}),p=this.device.createBindGroup({layout:this.updatePositionPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:n}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:o}}]}),g=this.device.createBindGroup({layout:this.configLayout,entries:[{binding:0,resource:{buffer:i}}]}),m=this.device.createBindGroup({layout:this.applyConstraintPipeline.getBindGroupLayout(2),entries:[{binding:0,resource:{buffer:h}}]});this.objects.push({cloth:e,positionBuffer:n,estimatedPositionBuffer:s,velocityBuffer:o,inverseMasseBuffer:r,restValueBuffer:a,complianceBuffer:c,affectedParticlesBuffer:l,configBuffer:i,colorBuffer:h,colorWriteBuffer:u,eulerBindGroup:f,constraintBindGroup:d,positionBindGroup:p,configBindGroup:g,colorBindGroup:m})}writeAllBuffer(e,t){this.device.queue.writeBuffer(e,0,t,0,t.length)}}function I(e){return e+3&-4}!function(e){e.CPU="cpu",e.GPU="gpu"}(A||(A={}));class D{constructor(e,t,i){this.app=e,this.device=t,this.limits=i,this.renderNeeded=!0,this.config={paused:!0,solverType:A.GPU,cpuSolver:{deltaTime:1/60,subSteps:15,relaxation:1,method:z.GaussSeidel},gpuSolver:{deltaTime:1/60,subSteps:10,relaxation:1},cloth:{unit:.01,density:.27,width:10,height:10,widthDivisions:1,heightDivisions:1,stretchCompliance:0,bendCompliance:.3}}}attach(e){this.el=e,this.updateApp(this.config,!0),setInterval((()=>this.run()),50),window.addEventListener("keypress",(e=>{switch(e.code){case"Space":this.togglePlay();break;case"KeyW":this.app.cloth.wireframe=!this.app.cloth.wireframe,m.info(`wireframe mode **${this.app.cloth.wireframe?"enabled":"disabled"}**`)}}))}run(){if(!this.renderNeeded)return;this.el.innerHTML=this.render(),this.renderNeeded=!1;const e=document.getElementById("play"),t=document.getElementById("restart"),i=document.getElementById("apply"),n=document.getElementById("solver-type"),s=document.getElementById("cpu-method");e.addEventListener("click",(e=>{e.preventDefault(),this.togglePlay()})),t.addEventListener("click",(e=>{e.preventDefault(),this.restartSimulation()})),i.addEventListener("click",(e=>{e.preventDefault(),this.apply()})),n.addEventListener("change",(()=>{this.config=this.buildConfiguration()})),s&&s.addEventListener("change",(()=>{this.config=this.buildConfiguration()}))}render(){return`\n            <form>\n                <div>\n                    <div class="column">\n                        <label for="cloth-unit">\n                            <span>unit</span>\n                            <input type="number" id="cloth-unit" name="cloth-unit"\n                                value=${this.config.cloth.unit}\n                                step=0.001\n                                min=0.000001\n                                max=1000 />\n                        </label>\n                        <label for="cloth-density">\n                            <span>density</span>\n                            <input type="number" id="cloth-density" name="cloth-density"\n                                value=${this.config.cloth.density}\n                                step=0.001\n                                min=0.000001\n                                max=1000 />\n                        </label>\n                        <label for="cloth-width">\n                            <span>width</span>\n                            <input type="number" id="cloth-width" name="cloth-width"\n                                value=${this.config.cloth.width}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-height">\n                            <span>height</span>\n                            <input type="number" id="cloth-height" name="cloth-height"\n                                value=${this.config.cloth.height}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n                        <label for="cloth-width-divisions">\n                            <span>width-division</span>\n                            <input type="number" id="cloth-width-divisions" name="cloth-width-divisions"\n                                value=${this.config.cloth.widthDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-height-divisions">\n                            <span>height-division</span>\n                            <input type="number" id="cloth-height-divisions" name="cloth-height-divisions"\n                                value=${this.config.cloth.heightDivisions}\n                                step=1\n                                min=0\n                                max=500 />\n                        </label>\n\n                        <label for="cloth-stretch-compliance">\n                            <span>stretch compliance</span>\n                            <input type="number" id="cloth-stretch-compliance" name="cloth-stretch-compliance"\n                                value=${this.config.cloth.stretchCompliance}\n                                step=0.1\n                                min=0\n                                max=1 />\n                        </label>\n\n                        <label for="cloth-bend-compliance">\n                            <span>bend compliance</span>\n                            <input type="number" id="cloth-bend-compliance" name="cloth-bend-compliance"\n                                value=${this.config.cloth.bendCompliance}\n                                step=0.1\n                                min=0\n                                max=1 />\n                        </label>\n                    </div>\n\n                    <div class="column">\n                        <label for="solver-type">\n                            <span>solver type</span>\n                            <select id="solver-type" name="solver-type">\n                                <option ${this.config.solverType===A.CPU?"selected":""} value=${A.CPU}>CPU</option>\n                                <option ${this.config.solverType===A.GPU?"selected":""} value=${A.GPU}>GPU</option>\n                            </select>\n                        </label>\n\n                        ${this.config.solverType===A.CPU?this.renderCPUSolverForm():this.renderGPUSolverForm()}\n                    </div>\n                </div>\n\n                <div class="row">\n                    <button id="play">${this.config.paused?"Play":"Pause"}</button>\n                    <button id="restart">Restart</button>\n                    <button id="apply">Apply</button>\n                </div>\n            </form>\n        `}renderCPUSolverForm(){const e=`\n            <div>\n                <label for="cpu-relaxation">\n                        <span>relaxation</span>\n                        <input type="number" id="cpu-relaxation" name="cpu-relaxation"\n                            value=${this.config.cpuSolver.relaxation}\n                            step=0.05\n                            min=0\n                            max=2 />\n                </label>\n            </div>\n        `;return`\n            <div>\n                <label for="cpu-method">\n                    <span>method</span>\n                    <select id="cpu-method" name="cpu-method">\n                        <option ${this.config.cpuSolver.method===z.Jacobi?"selected":""} value=${z.Jacobi}>Jacobi</option>\n                        <option ${this.config.cpuSolver.method===z.GaussSeidel?"selected":""} value=${z.GaussSeidel}>Gauss-Seidel</option>\n                    </select>\n                </label>\n                <label for="cpu-sub-steps">\n                    <span>sub-steps</span>\n                    <input type="number" id="cpu-sub-steps" name="cpu-sub-steps"\n                        value=${this.config.cpuSolver.subSteps}\n                        step=1\n                        min=1\n                        max=500 />\n                </label>\n\n                ${this.config.cpuSolver.method===z.Jacobi?e:""}\n            </div>\n        `}renderGPUSolverForm(){return`\n            <div>\n                <label for="gpu-sub-steps">\n                    <span>sub-steps</span>\n                    <input type="number" id="gpu-sub-steps" name="gpu-sub-steps"\n                        value=${this.config.gpuSolver.subSteps}\n                        step=1\n                        min=1\n                        max=500 />\n                </label>\n            </div>\n        `}updateApp(e,t=!1){const i=e.cloth.width!==this.config.cloth.width||e.cloth.height!==this.config.cloth.height||e.cloth.widthDivisions!==this.config.cloth.widthDivisions||e.cloth.heightDivisions!==this.config.cloth.heightDivisions,n=e.cloth.stretchCompliance!==this.config.cloth.stretchCompliance||e.cloth.bendCompliance!==this.config.cloth.bendCompliance||e.cloth.unit!==this.config.cloth.unit||e.cloth.density!==this.config.cloth.density;(t||i)&&(m.info("resetting the simulation with a new cloth geometry"),this.app.cloth.geometry=M(this.device,e.cloth.width,e.cloth.height,e.cloth.widthDivisions,e.cloth.heightDivisions)),(t||n)&&(this.app.cloth.config={unit:e.cloth.unit,density:e.cloth.density,stretchCompliance:e.cloth.stretchCompliance,bendCompliance:e.cloth.bendCompliance}),this.app.solver=e.solverType===A.CPU?new T(e.cpuSolver):new $(e.gpuSolver,this.device,this.limits),this.app.solver.add(this.app.cloth)}buildConfiguration(){const e=new FormData(this.el.querySelector("form")),t=Object.assign(Object.assign({},this.config),{solverType:e.get("solver-type"),cloth:{unit:parseFloat(e.get("cloth-unit")),density:parseFloat(e.get("cloth-density")),width:parseFloat(e.get("cloth-width")),height:parseFloat(e.get("cloth-height")),widthDivisions:parseInt(e.get("cloth-width-divisions")),heightDivisions:parseInt(e.get("cloth-height-divisions")),stretchCompliance:parseFloat(e.get("cloth-stretch-compliance")),bendCompliance:parseFloat(e.get("cloth-bend-compliance"))}});return this.config.solverType===A.CPU&&(t.cpuSolver=Object.assign(Object.assign({},this.config.cpuSolver),{method:e.get("cpu-method"),subSteps:parseInt(e.get("cpu-sub-steps"))}),this.config.cpuSolver.method===z.Jacobi&&(t.cpuSolver.relaxation=parseFloat(e.get("cpu-relaxation")))),this.config.solverType===A.GPU&&(t.gpuSolver=Object.assign(Object.assign({},this.config.gpuSolver),{subSteps:parseInt(e.get("gpu-sub-steps"))})),this.renderNeeded=!0,t}apply(){const e=this.buildConfiguration();this.updateApp(e),this.config=e}restartSimulation(){this.app.cloth.geometry=M(this.device,this.config.cloth.width,this.config.cloth.height,this.config.cloth.widthDivisions,this.config.cloth.heightDivisions)}togglePlay(){this.config.paused=!this.config.paused,this.app.paused=this.config.paused,this.renderNeeded=!0}}(function(){return e=this,t=void 0,n=function*(){const e=navigator.gpu;if(!e)throw new Error("WebGPU is not supported on this browser.");const t=yield e.requestAdapter();let i="";for(let e in t.limits)i+=` - ${e}: **${t.limits[e]}**\n`;m.info(`limits:\n ${i}`);const n=yield t.requestDevice(),s=document.getElementById("app");s.width=1e3,s.height=512;const o=new L(s,n),r=new D(o,n,t.limits);return m.attach(document.getElementById("logger")),C.attach(document.getElementById("monitor")),r.attach(document.getElementById("controller")),o.run()},new((i=void 0)||(i=Promise))((function(s,o){function r(e){try{c(n.next(e))}catch(e){o(e)}}function a(e){try{c(n.throw(e))}catch(e){o(e)}}function c(e){var t;e.done?s(e.value):(t=e.value,t instanceof i?t:new i((function(e){e(t)}))).then(r,a)}c((n=n.apply(e,t||[])).next())}));var e,t,i,n})().then((()=>m.info("done"))).catch((e=>console.error(e.toString()+"\n"+e.stack)))}();